{
  "address": "0x29A51965a8C0e9B7273E7b4f3f1735A1B99da6C0",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "domainID",
          "type": "uint256"
        }
      ],
      "name": "getAddressForDomain",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getCounter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getGasMaster",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "getQuote",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "_origin",
          "type": "uint32"
        },
        {
          "internalType": "bytes32",
          "name": "_sender",
          "type": "bytes32"
        },
        {
          "internalType": "bytes",
          "name": "_body",
          "type": "bytes"
        }
      ],
      "name": "handle",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint32",
          "name": "domain",
          "type": "uint32"
        },
        {
          "internalType": "uint256",
          "name": "gasAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "hitEmUp",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "interchainSecurityModule",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "moduleType",
      "outputs": [
        {
          "internalType": "uint8",
          "name": "",
          "type": "uint8"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "inputs",
          "type": "uint256[]"
        }
      ],
      "name": "sendDataArbGoerli",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "inputs",
          "type": "uint256[]"
        }
      ],
      "name": "sendDataBase",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "inputs",
          "type": "uint256[]"
        }
      ],
      "name": "sendDataGnosis",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "inputs",
          "type": "uint256[]"
        }
      ],
      "name": "sendDataGoerli",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "inputs",
          "type": "uint256[]"
        }
      ],
      "name": "sendDataMumbai",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "domainID",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "recipentAddy",
          "type": "address"
        }
      ],
      "name": "setDomainToAddress",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "localIGP",
          "type": "address"
        }
      ],
      "name": "setGasMaster",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "maiLBox",
          "type": "address"
        }
      ],
      "name": "setMailBox",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_metadata",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "_message",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x94f693b8e62686b7a491b70e95009afb05d5ecce2905babb2da569780883b89b",
  "receipt": {
    "to": null,
    "from": "0x793448209Ef713CAe41437C7DaA219b59BEF1A4A",
    "contractAddress": "0x29A51965a8C0e9B7273E7b4f3f1735A1B99da6C0",
    "transactionIndex": 1,
    "gasUsed": "1563718",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x21da91c6d87c31c12f0b045d26ee4246f4c07a78dc2cec40b03c1c0da1c3757e",
    "transactionHash": "0x94f693b8e62686b7a491b70e95009afb05d5ecce2905babb2da569780883b89b",
    "logs": [],
    "blockNumber": 49887594,
    "cumulativeGasUsed": "1563718",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "c03150f71627b5dbddb8bb21af2b946a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"domainID\",\"type\":\"uint256\"}],\"name\":\"getAddressForDomain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getCounter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getGasMaster\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getQuote\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"_origin\",\"type\":\"uint32\"},{\"internalType\":\"bytes32\",\"name\":\"_sender\",\"type\":\"bytes32\"},{\"internalType\":\"bytes\",\"name\":\"_body\",\"type\":\"bytes\"}],\"name\":\"handle\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint32\",\"name\":\"domain\",\"type\":\"uint32\"},{\"internalType\":\"uint256\",\"name\":\"gasAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"hitEmUp\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"interchainSecurityModule\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"moduleType\",\"outputs\":[{\"internalType\":\"uint8\",\"name\":\"\",\"type\":\"uint8\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"sendDataArbGoerli\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"sendDataBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"sendDataGnosis\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"sendDataGoerli\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"sendDataMumbai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"domainID\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"recipentAddy\",\"type\":\"address\"}],\"name\":\"setDomainToAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"localIGP\",\"type\":\"address\"}],\"name\":\"setGasMaster\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"maiLBox\",\"type\":\"address\"}],\"name\":\"setMailBox\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_metadata\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"_message\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Facets/Hyperlane/HyperFacet.sol\":\"HyperFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"UMA/packages/core/contracts/common/implementation/AncillaryData.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title Library for encoding and decoding ancillary data for DVM price requests.\\n * @notice  We assume that on-chain ancillary data can be formatted directly from bytes to utf8 encoding via\\n * web3.utils.hexToUtf8, and that clients will parse the utf8-encoded ancillary data as a comma-delimitted key-value\\n * dictionary. Therefore, this library provides internal methods that aid appending to ancillary data from Solidity\\n * smart contracts. More details on UMA's ancillary data guidelines below:\\n * https://docs.google.com/document/d/1zhKKjgY1BupBGPPrY_WOJvui0B6DMcd-xDR8-9-SPDw/edit\\n */\\nlibrary AncillaryData {\\n    // This converts the bottom half of a bytes32 input to hex in a highly gas-optimized way.\\n    // Source: the brilliant implementation at https://gitter.im/ethereum/solidity?at=5840d23416207f7b0ed08c9b.\\n    function toUtf8Bytes32Bottom(bytes32 bytesIn) private pure returns (bytes32) {\\n        unchecked {\\n            uint256 x = uint256(bytesIn);\\n\\n            // Nibble interleave\\n            x = x & 0x00000000000000000000000000000000ffffffffffffffffffffffffffffffff;\\n            x = (x | (x * 2 ** 64)) & 0x0000000000000000ffffffffffffffff0000000000000000ffffffffffffffff;\\n            x = (x | (x * 2 ** 32)) & 0x00000000ffffffff00000000ffffffff00000000ffffffff00000000ffffffff;\\n            x = (x | (x * 2 ** 16)) & 0x0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff;\\n            x = (x | (x * 2 ** 8)) & 0x00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff;\\n            x = (x | (x * 2 ** 4)) & 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\\n\\n            // Hex encode\\n            uint256 h = (x & 0x0808080808080808080808080808080808080808080808080808080808080808) / 8;\\n            uint256 i = (x & 0x0404040404040404040404040404040404040404040404040404040404040404) / 4;\\n            uint256 j = (x & 0x0202020202020202020202020202020202020202020202020202020202020202) / 2;\\n            x = x + (h & (i | j)) * 0x27 + 0x3030303030303030303030303030303030303030303030303030303030303030;\\n\\n            // Return the result.\\n            return bytes32(x);\\n        }\\n    }\\n\\n    /**\\n     * @notice Returns utf8-encoded bytes32 string that can be read via web3.utils.hexToUtf8.\\n     * @dev Will return bytes32 in all lower case hex characters and without the leading 0x.\\n     * This has minor changes from the toUtf8BytesAddress to control for the size of the input.\\n     * @param bytesIn bytes32 to encode.\\n     * @return utf8 encoded bytes32.\\n     */\\n    function toUtf8Bytes(bytes32 bytesIn) internal pure returns (bytes memory) {\\n        return abi.encodePacked(toUtf8Bytes32Bottom(bytesIn >> 128), toUtf8Bytes32Bottom(bytesIn));\\n    }\\n\\n    /**\\n     * @notice Returns utf8-encoded address that can be read via web3.utils.hexToUtf8.\\n     * Source: https://ethereum.stackexchange.com/questions/8346/convert-address-to-string/8447#8447\\n     * @dev Will return address in all lower case characters and without the leading 0x.\\n     * @param x address to encode.\\n     * @return utf8 encoded address bytes.\\n     */\\n    function toUtf8BytesAddress(address x) internal pure returns (bytes memory) {\\n        return\\n            abi.encodePacked(toUtf8Bytes32Bottom(bytes32(bytes20(x)) >> 128), bytes8(toUtf8Bytes32Bottom(bytes20(x))));\\n    }\\n\\n    /**\\n     * @notice Converts a uint into a base-10, UTF-8 representation stored in a `string` type.\\n     * @dev This method is based off of this code: https://stackoverflow.com/a/65707309.\\n     */\\n    function toUtf8BytesUint(uint256 x) internal pure returns (bytes memory) {\\n        if (x == 0) {\\n            return \\\"0\\\";\\n        }\\n        uint256 j = x;\\n        uint256 len;\\n        while (j != 0) {\\n            len++;\\n            j /= 10;\\n        }\\n        bytes memory bstr = new bytes(len);\\n        uint256 k = len;\\n        while (x != 0) {\\n            k = k - 1;\\n            uint8 temp = (48 + uint8(x - (x / 10) * 10));\\n            bytes1 b1 = bytes1(temp);\\n            bstr[k] = b1;\\n            x /= 10;\\n        }\\n        return bstr;\\n    }\\n\\n    function appendKeyValueBytes32(\\n        bytes memory currentAncillaryData,\\n        bytes memory key,\\n        bytes32 value\\n    ) internal pure returns (bytes memory) {\\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8Bytes(value));\\n    }\\n\\n    /**\\n     * @notice Adds \\\"key:value\\\" to `currentAncillaryData` where `value` is an address that first needs to be converted\\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\\\"k1:v1\\\"`, then this function will return\\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\\n     * @param value An address to set as the value in the key:value pair to append to `currentAncillaryData`.\\n     * @return Newly appended ancillary data.\\n     */\\n    function appendKeyValueAddress(\\n        bytes memory currentAncillaryData,\\n        bytes memory key,\\n        address value\\n    ) internal pure returns (bytes memory) {\\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesAddress(value));\\n    }\\n\\n    /**\\n     * @notice Adds \\\"key:value\\\" to `currentAncillaryData` where `value` is a uint that first needs to be converted\\n     * to utf8 bytes. For example, if `utf8(currentAncillaryData)=\\\"k1:v1\\\"`, then this function will return\\n     * `utf8(k1:v1,key:value)`, and if `currentAncillaryData` is blank, then this will return `utf8(key:value)`.\\n     * @param currentAncillaryData This bytes data should ideally be able to be utf8-decoded, but its OK if not.\\n     * @param key Again, this bytes data should ideally be able to be utf8-decoded, but its OK if not.\\n     * @param value A uint to set as the value in the key:value pair to append to `currentAncillaryData`.\\n     * @return Newly appended ancillary data.\\n     */\\n    function appendKeyValueUint(\\n        bytes memory currentAncillaryData,\\n        bytes memory key,\\n        uint256 value\\n    ) internal pure returns (bytes memory) {\\n        bytes memory prefix = constructPrefix(currentAncillaryData, key);\\n        return abi.encodePacked(currentAncillaryData, prefix, toUtf8BytesUint(value));\\n    }\\n\\n    /**\\n     * @notice Helper method that returns the left hand side of a \\\"key:value\\\" pair plus the colon \\\":\\\" and a leading\\n     * comma \\\",\\\" if the `currentAncillaryData` is not empty. The return value is intended to be prepended as a prefix to\\n     * some utf8 value that is ultimately added to a comma-delimited, key-value dictionary.\\n     */\\n    function constructPrefix(bytes memory currentAncillaryData, bytes memory key) internal pure returns (bytes memory) {\\n        if (currentAncillaryData.length > 0) {\\n            return abi.encodePacked(\\\",\\\", key, \\\":\\\");\\n        } else {\\n            return abi.encodePacked(key, \\\":\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa404e9acbf7f6e2eec984180d8799296ac6340ee71911f1e2a1957dbdfa6ae95\",\"license\":\"AGPL-3.0-only\"},\"UMA/packages/core/contracts/optimistic-oracle-v3/implementation/ClaimData.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.20;\\n\\nimport { AncillaryData as ClaimData } from \\\"../../common/implementation/AncillaryData.sol\\\";\\n\",\"keccak256\":\"0x552b61501891e2a86afdb75f61bec171d4b6d6e288b2d524bdbfcea20e66fadc\",\"license\":\"AGPL-3.0-only\"},\"UMA/packages/core/contracts/optimistic-oracle-v3/interfaces/OptimisticOracleV3Interface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity 0.8.20;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\n/**\\n * @title Optimistic Oracle V3 Interface that callers must use to assert truths about the world.\\n */\\ninterface OptimisticOracleV3Interface {\\n    // Struct grouping together the settings related to the escalation manager stored in the assertion.\\n    struct EscalationManagerSettings {\\n        bool arbitrateViaEscalationManager; // False if the DVM is used as an oracle (EscalationManager on True).\\n        bool discardOracle; // False if Oracle result is used for resolving assertion after dispute.\\n        bool validateDisputers; // True if the EM isDisputeAllowed should be checked on disputes.\\n        address assertingCaller; // Stores msg.sender when assertion was made.\\n        address escalationManager; // Address of the escalation manager (zero address if not configured).\\n    }\\n\\n    // Struct for storing properties and lifecycle of an assertion.\\n    struct Assertion {\\n        EscalationManagerSettings escalationManagerSettings; // Settings related to the escalation manager.\\n        address asserter; // Address of the asserter.\\n        uint64 assertionTime; // Time of the assertion.\\n        bool settled; // True if the request is settled.\\n        IERC20 currency; // ERC20 token used to pay rewards and fees.\\n        uint64 expirationTime; // Unix timestamp marking threshold when the assertion can no longer be disputed.\\n        bool settlementResolution; // Resolution of the assertion (false till resolved).\\n        bytes32 domainId; // Optional domain that can be used to relate the assertion to others in the escalationManager.\\n        bytes32 identifier; // UMA DVM identifier to use for price requests in the event of a dispute.\\n        uint256 bond; // Amount of currency that the asserter has bonded.\\n        address callbackRecipient; // Address that receives the callback.\\n        address disputer; // Address of the disputer.\\n    }\\n\\n    // Struct for storing cached currency whitelist.\\n    struct WhitelistedCurrency {\\n        bool isWhitelisted; // True if the currency is whitelisted.\\n        uint256 finalFee; // Final fee of the currency.\\n    }\\n\\n    /**\\n     * @notice Returns the default identifier used by the Optimistic Oracle V3.\\n     * @return The default identifier.\\n     */\\n    function defaultIdentifier() external view returns (bytes32);\\n\\n    /**\\n     * @notice Fetches information about a specific assertion and returns it.\\n     * @param assertionId unique identifier for the assertion to fetch information for.\\n     * @return assertion information about the assertion.\\n     */\\n    function getAssertion(bytes32 assertionId) external view returns (Assertion memory);\\n\\n    /**\\n     * @notice Asserts a truth about the world, using the default currency and liveness. No callback recipient or\\n     * escalation manager is enabled. The caller is expected to provide a bond of finalFee/burnedBondPercentage\\n     * (with burnedBondPercentage set to 50%, the bond is 2x final fee) of the default currency.\\n     * @dev The caller must approve this contract to spend at least the result of getMinimumBond(defaultCurrency).\\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\\n     * @param asserter receives bonds back at settlement. This could be msg.sender or\\n     * any other account that the caller wants to receive the bond at settlement time.\\n     * @return assertionId unique identifier for this assertion.\\n     */\\n    function assertTruthWithDefaults(bytes memory claim, address asserter) external returns (bytes32);\\n\\n    /**\\n     * @notice Asserts a truth about the world, using a fully custom configuration.\\n     * @dev The caller must approve this contract to spend at least bond amount of currency.\\n     * @param claim the truth claim being asserted. This is an assertion about the world, and is verified by disputers.\\n     * @param asserter receives bonds back at settlement. This could be msg.sender or\\n     * any other account that the caller wants to receive the bond at settlement time.\\n     * @param callbackRecipient if configured, this address will receive a function call assertionResolvedCallback and\\n     * assertionDisputedCallback at resolution or dispute respectively. Enables dynamic responses to these events. The\\n     * recipient _must_ implement these callbacks and not revert or the assertion resolution will be blocked.\\n     * @param escalationManager if configured, this address will control escalation properties of the assertion. This\\n     * means a) choosing to arbitrate via the UMA DVM, b) choosing to discard assertions on dispute, or choosing to\\n     * validate disputes. Combining these, the asserter can define their own security properties for the assertion.\\n     * escalationManager also _must_ implement the same callbacks as callbackRecipient.\\n     * @param liveness time to wait before the assertion can be resolved. Assertion can be disputed in this time.\\n     * @param currency bond currency pulled from the caller and held in escrow until the assertion is resolved.\\n     * @param bond amount of currency to pull from the caller and hold in escrow until the assertion is resolved. This\\n     * must be >= getMinimumBond(address(currency)).\\n     * @param identifier UMA DVM identifier to use for price requests in the event of a dispute. Must be pre-approved.\\n     * @param domainId optional domain that can be used to relate this assertion to others in the escalationManager and\\n     * can be used by the configured escalationManager to define custom behavior for groups of assertions. This is\\n     * typically used for \\\"escalation games\\\" by changing bonds or other assertion properties based on the other\\n     * assertions that have come before. If not needed this value should be 0 to save gas.\\n     * @return assertionId unique identifier for this assertion.\\n     */\\n    function assertTruth(\\n        bytes memory claim,\\n        address asserter,\\n        address callbackRecipient,\\n        address escalationManager,\\n        uint64 liveness,\\n        IERC20 currency,\\n        uint256 bond,\\n        bytes32 identifier,\\n        bytes32 domainId\\n    ) external returns (bytes32);\\n\\n    /**\\n     * @notice Fetches information about a specific identifier & currency from the UMA contracts and stores a local copy\\n     * of the information within this contract. This is used to save gas when making assertions as we can avoid an\\n     * external call to the UMA contracts to fetch this.\\n     * @param identifier identifier to fetch information for and store locally.\\n     * @param currency currency to fetch information for and store locally.\\n     */\\n    function syncUmaParams(bytes32 identifier, address currency) external;\\n\\n    /**\\n     * @notice Resolves an assertion. If the assertion has not been disputed, the assertion is resolved as true and the\\n     * asserter receives the bond. If the assertion has been disputed, the assertion is resolved depending on the oracle\\n     * result. Based on the result, the asserter or disputer receives the bond. If the assertion was disputed then an\\n     * amount of the bond is sent to the UMA Store as an oracle fee based on the burnedBondPercentage. The remainder of\\n     * the bond is returned to the asserter or disputer.\\n     * @param assertionId unique identifier for the assertion to resolve.\\n     */\\n    function settleAssertion(bytes32 assertionId) external;\\n\\n    /**\\n     * @notice Settles an assertion and returns the resolution.\\n     * @param assertionId unique identifier for the assertion to resolve and return the resolution for.\\n     * @return resolution of the assertion.\\n     */\\n    function settleAndGetAssertionResult(bytes32 assertionId) external returns (bool);\\n\\n    /**\\n     * @notice Fetches the resolution of a specific assertion and returns it. If the assertion has not been settled then\\n     * this will revert. If the assertion was disputed and configured to discard the oracle resolution return false.\\n     * @param assertionId unique identifier for the assertion to fetch the resolution for.\\n     * @return resolution of the assertion.\\n     */\\n    function getAssertionResult(bytes32 assertionId) external view returns (bool);\\n\\n    /**\\n     * @notice Returns the minimum bond amount required to make an assertion. This is calculated as the final fee of the\\n     * currency divided by the burnedBondPercentage. If burn percentage is 50% then the min bond is 2x the final fee.\\n     * @param currency currency to calculate the minimum bond for.\\n     * @return minimum bond amount.\\n     */\\n    function getMinimumBond(address currency) external view returns (uint256);\\n\\n    event AssertionMade(\\n        bytes32 indexed assertionId,\\n        bytes32 domainId,\\n        bytes claim,\\n        address indexed asserter,\\n        address callbackRecipient,\\n        address escalationManager,\\n        address caller,\\n        uint64 expirationTime,\\n        IERC20 currency,\\n        uint256 bond,\\n        bytes32 indexed identifier\\n    );\\n\\n    event AssertionDisputed(bytes32 indexed assertionId, address indexed caller, address indexed disputer);\\n\\n    event AssertionSettled(\\n        bytes32 indexed assertionId,\\n        address indexed bondRecipient,\\n        bool disputed,\\n        bool settlementResolution,\\n        address settleCaller\\n    );\\n\\n    event AdminPropertiesSet(IERC20 defaultCurrency, uint64 defaultLiveness, uint256 burnedBondPercentage);\\n}\\n\",\"keccak256\":\"0xdb1d8a200baea7a28e6f7d2bc19b59b09a417bc43709a04e0b714e8020577f1f\",\"license\":\"AGPL-3.0-only\"},\"contracts/Facets/Hyperlane/HyperFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\nimport \\\"./Interfaces/IMailbox.sol\\\";\\nimport \\\"./Interfaces/IInterchainGasPaymaster.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"../UMAFacet.sol\\\";\\nimport \\\"../ManagerFacet.sol\\\";\\n\\nlibrary HyperLib {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.hyperlane.storage\\\");\\n\\n    struct HyperState {\\n        address mailBox;\\n        address igp;\\n        mapping(uint256 => address) domainToAddress;\\n        uint256 counter;\\n    }\\n\\n    function diamondStorage() internal pure returns (HyperState storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function setDomainToAddress(\\n        uint256 domainID,\\n        address recipentAddy\\n    ) internal {\\n        HyperState storage hyperState = diamondStorage();\\n        hyperState.domainToAddress[domainID] = recipentAddy;\\n    }\\n\\n    function getRecipient(uint256 domainID) internal view returns (address) {\\n        HyperState storage hyperState = diamondStorage();\\n        return hyperState.domainToAddress[domainID];\\n    }\\n\\n    function increaseCounter() internal {\\n        HyperState storage hyperState = diamondStorage();\\n        hyperState.counter = hyperState.counter + 1;\\n    }\\n\\n    function getCounter() internal view returns (uint256) {\\n        HyperState storage hyperState = diamondStorage();\\n        return hyperState.counter;\\n    }\\n\\n    function hitEmUp(\\n        uint32 targetDomain,\\n        uint256 gasAmount,\\n        uint256 _value\\n    ) internal {\\n        HyperState storage hyperState = diamondStorage();\\n        IMailbox MailBox = IMailbox(hyperState.mailBox);\\n        IInterchainGasPaymaster IGP = IInterchainGasPaymaster(hyperState.igp);\\n\\n        address targetAddress = hyperState.domainToAddress[targetDomain];\\n        bytes32 messageID = MailBox.dispatch(\\n            targetDomain,\\n            addressToBytes32(targetAddress),\\n            abi.encode(msg.sender)\\n        );\\n\\n        IGP.payForGas{value: _value}(\\n            messageID,\\n            targetDomain,\\n            gasAmount,\\n            msg.sender // refunds are returned to the sender\\n        );\\n    }\\n\\n    function sendMessage(\\n        uint32 targetDomain,\\n        uint256 gasAmount,\\n        uint256 _value,\\n        bytes memory data\\n    ) internal {\\n        HyperState storage hyperState = diamondStorage();\\n        IMailbox MailBox = IMailbox(hyperState.mailBox);\\n        IInterchainGasPaymaster IGP = IInterchainGasPaymaster(hyperState.igp);\\n\\n        address targetAddress = hyperState.domainToAddress[targetDomain];\\n        bytes32 messageID = MailBox.dispatch(\\n            targetDomain,\\n            addressToBytes32(targetAddress),\\n            abi.encode(msg.sender, data)\\n        );\\n\\n        IGP.payForGas{value: _value}(\\n            messageID,\\n            targetDomain,\\n            gasAmount,\\n            msg.sender // refunds are returned to the sender\\n        );\\n    }\\n\\n    uint256 public constant gasCost = 300000;\\n\\n    function sendDataMumbai(uint256[] memory input) internal {\\n        uint32 domainTarget = 80001;\\n        uint256 gasEstimate = getQuote(domainTarget, gasCost);\\n        bytes memory data = ManagerLib.getCurrentFlow();\\n\\n        bytes memory dataFlow = ManagerLib.addDataToFront(input, data);\\n        sendMessage(domainTarget, gasCost, gasEstimate, dataFlow);\\n    }\\n\\n    function sendDataArbGoerli(uint256[] memory input) internal {\\n        uint32 domainTarget = 421613;\\n        uint256 gasEstimate = getQuote(domainTarget, gasCost);\\n        bytes memory data = ManagerLib.getCurrentFlow();\\n        bytes memory dataFlow = ManagerLib.addDataToFront(input, data);\\n\\n        sendMessage(domainTarget, gasCost, gasEstimate, dataFlow);\\n    }\\n\\n    function sendDataGoerli(uint256[] memory input) internal {\\n        uint32 domainTarget = 5;\\n        uint256 gasEstimate = getQuote(domainTarget, gasCost);\\n        bytes memory data = ManagerLib.getCurrentFlow();\\n        bytes memory dataFlow = ManagerLib.addDataToFront(input, data);\\n\\n        sendMessage(domainTarget, gasCost, gasEstimate, dataFlow);\\n    }\\n\\n    function sendDataBase(uint256[] memory input) internal {\\n        uint32 domainTarget = 84531;\\n        uint256 gasEstimate = getQuote(domainTarget, gasCost);\\n        bytes memory data = ManagerLib.getCurrentFlow();\\n        bytes memory dataFlow = ManagerLib.addDataToFront(input, data);\\n\\n        sendMessage(domainTarget, gasCost, gasEstimate, dataFlow);\\n    }\\n\\n    function sendDataGnosis(uint256[] memory input) internal {\\n        uint32 domainTarget = 100;\\n        uint256 gasEstimate = getQuote(domainTarget, gasCost);\\n        bytes memory data = ManagerLib.getCurrentFlow();\\n        bytes memory dataFlow = ManagerLib.addDataToFront(input, data);\\n\\n        sendMessage(domainTarget, gasCost, gasEstimate, dataFlow);\\n    }\\n\\n    function addressToBytes32(address _addr) internal pure returns (bytes32) {\\n        return bytes32(uint256(uint160(_addr)));\\n    }\\n\\n    function interchainSecurityModule() internal view returns (address) {\\n        return address(this);\\n    }\\n\\n    function setMailBox(address maiLBox) internal {\\n        HyperState storage hyperState = diamondStorage();\\n        hyperState.mailBox = maiLBox;\\n    }\\n\\n    function setGasMaster(address localIGP) internal {\\n        HyperState storage hyperState = diamondStorage();\\n        hyperState.igp = localIGP;\\n    }\\n\\n    function getGasMaster() internal view returns (address) {\\n        HyperState storage hyperState = diamondStorage();\\n        return hyperState.igp;\\n    }\\n\\n    function getAddressForDomain(\\n        uint256 domainID\\n    ) internal view returns (address) {\\n        HyperState storage hyperState = diamondStorage();\\n        return hyperState.domainToAddress[domainID];\\n    }\\n\\n    function getQuote(\\n        uint32 domain,\\n        uint256 amount\\n    ) internal view returns (uint256) {\\n        HyperState storage hyperState = diamondStorage();\\n        IInterchainGasPaymaster IGP = IInterchainGasPaymaster(hyperState.igp);\\n        return IGP.quoteGasPayment(domain, amount);\\n    }\\n\\n    function verify(\\n        bytes calldata _metadata,\\n        bytes calldata _message\\n    ) internal returns (bool) {\\n        HyperState storage hyperState = diamondStorage();\\n        UMALib.UMAState storage umaState = UMALib.diamondStorage();\\n\\n        hyperState.counter += 1;\\n        if (address(umaState.oov3) != address(0)) {\\n            bytes32 dataID = bytes32(hyperState.counter);\\n            bytes32 assertionID = UMALib.assertDataFor(\\n                dataID,\\n                bytes32(_message),\\n                address(this)\\n            );\\n            umaState.messageToAssertionID[bytes32(_message)] = assertionID;\\n        }\\n        //When the validator calls verify, we lock the state so the relayer pauses\\n        //Then after a 30s period for UMA review re-allow transactions to go through\\n        //Then the relayer is able to work. Muahhahhah\\n        return true;\\n    }\\n\\n    function receiveMessage(\\n        uint32 _origin,\\n        bytes32 _sender,\\n        bytes calldata _body\\n    ) internal {\\n        UMALib.UMAState storage umaState = UMALib.diamondStorage();\\n        if (address(umaState.oov3) != address(0)) {\\n            bytes32 assertionID = umaState.messageToAssertionID[bytes32(_body)];\\n            UMALib.settleAndGetAssertionResult(assertionID);\\n        }\\n\\n        HyperLib.increaseCounter();\\n        //Now we can continue flow\\n        ManagerLib.startWorking(_body);\\n    }\\n\\n    function sendMessageToMumbai() internal {}\\n}\\n\\ncontract HyperFacet {\\n    function handle(\\n        uint32 _origin,\\n        bytes32 _sender,\\n        bytes calldata _body\\n    ) external {\\n        HyperLib.increaseCounter();\\n    }\\n\\n    function hitEmUp(\\n        uint32 domain,\\n        uint256 gasAmount,\\n        uint256 _value\\n    ) external payable {\\n        HyperLib.hitEmUp(domain, gasAmount, _value);\\n    }\\n\\n    function interchainSecurityModule() external view returns (address) {\\n        return HyperLib.interchainSecurityModule();\\n    }\\n\\n    function setMailBox(address maiLBox) external {\\n        HyperLib.setMailBox(maiLBox);\\n    }\\n\\n    function setGasMaster(address localIGP) external {\\n        HyperLib.setGasMaster(localIGP);\\n    }\\n\\n    function getGasMaster() external view returns (address) {\\n        return HyperLib.getGasMaster();\\n    }\\n\\n    function getCounter() external view returns (uint256) {\\n        return HyperLib.getCounter();\\n    }\\n\\n    function setDomainToAddress(\\n        uint256 domainID,\\n        address recipentAddy\\n    ) external {\\n        HyperLib.setDomainToAddress(domainID, recipentAddy);\\n    }\\n\\n    function getAddressForDomain(\\n        uint256 domainID\\n    ) external view returns (address) {\\n        return HyperLib.getAddressForDomain(domainID);\\n    }\\n\\n    function getQuote(\\n        uint32 domain,\\n        uint256 amount\\n    ) external view returns (uint256) {\\n        return HyperLib.getQuote(domain, amount);\\n    }\\n\\n    function moduleType() external pure returns (uint8) {\\n        return 6;\\n    }\\n\\n    function verify(\\n        bytes calldata _metadata,\\n        bytes calldata _message\\n    ) external returns (bool) {\\n        return HyperLib.verify(_metadata, _message);\\n    }\\n\\n    function sendDataMumbai(uint256[] memory inputs) external {\\n        HyperLib.sendDataMumbai(inputs);\\n    }\\n\\n    function sendDataArbGoerli(uint256[] memory inputs) external {\\n        HyperLib.sendDataArbGoerli(inputs);\\n    }\\n\\n    function sendDataGoerli(uint256[] memory inputs) external {\\n        HyperLib.sendDataGoerli(inputs);\\n    }\\n\\n    function sendDataBase(uint256[] memory inputs) external {\\n        HyperLib.sendDataBase(inputs);\\n    }\\n\\n    function sendDataGnosis(uint256[] memory inputs) external {\\n        HyperLib.sendDataGnosis(inputs);\\n    }\\n}\\n\",\"keccak256\":\"0xa4c1d18bf88c896a375c0868d3ba51d980d7d678435e99ff1fac0faf9c75f1e6\",\"license\":\"MIT\"},\"contracts/Facets/Hyperlane/Interfaces/IInterchainGasPaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.6.11;\\n\\n/**\\n * @title IInterchainGasPaymaster\\n * @notice Manages payments on a source chain to cover gas costs of relaying\\n * messages to destination chains.\\n */\\ninterface IInterchainGasPaymaster {\\n    /**\\n     * @notice Emitted when a payment is made for a message's gas costs.\\n     * @param messageId The ID of the message to pay for.\\n     * @param gasAmount The amount of destination gas paid for.\\n     * @param payment The amount of native tokens paid.\\n     */\\n    event GasPayment(\\n        bytes32 indexed messageId,\\n        uint256 gasAmount,\\n        uint256 payment\\n    );\\n\\n    function payForGas(\\n        bytes32 _messageId,\\n        uint32 _destinationDomain,\\n        uint256 _gasAmount,\\n        address _refundAddress\\n    ) external payable;\\n\\n    function quoteGasPayment(\\n        uint32 _destinationDomain,\\n        uint256 _gasAmount\\n    ) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xea5705377bcae5ff9dee6599d66f88c7e76a61169c2046a5efedcf4034354045\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/Facets/Hyperlane/Interfaces/IMailbox.sol\":{\"content\":\"// SPDX-License-Identifier: MIT OR Apache-2.0\\npragma solidity >=0.8.0;\\n\\ninterface IMailbox {\\n    function dispatch(\\n        uint32 _destinationDomain,\\n        bytes32 _recipientAddress,\\n        bytes calldata _messageBody\\n    ) external returns (bytes32);\\n\\n    function process(\\n        bytes calldata _metadata,\\n        bytes calldata _message\\n    ) external;\\n}\\n\",\"keccak256\":\"0xa43ec8f0dc8cab47ed22e647d3df0863633ee6972d6e3de7c0716aa25e8251dd\",\"license\":\"MIT OR Apache-2.0\"},\"contracts/Facets/ManagerFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Example library to show a simple example of diamond storage\\nimport \\\"hardhat/console.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary ManagerLib {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.manager.storage\\\");\\n\\n    struct ManagerState {\\n        uint256 huh;\\n        uint256[] lastResult;\\n        mapping(address => uint256[]) userIds;\\n        mapping(uint256 => flowGraph) userFlows;\\n        bytes[] afterSwapFlows;\\n        uint256 flowID;\\n        bool work;\\n        bool executionOccuring;\\n        bytes currentDataFlow;\\n    }\\n    struct flowGraph {\\n        bytes dataFlow;\\n        string description;\\n    }\\n    uint256 public constant INSTRUCTION_LENGTH = 0x20; //bytes5 type\\n\\n    function diamondStorage() internal pure returns (ManagerState storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function convertBytes5ArrayToBytes(\\n        bytes5[] memory data\\n    ) internal pure returns (bytes memory res) {\\n        for (uint i = 0; i < data.length; i++) {\\n            res = abi.encodePacked(res, data[i]);\\n        }\\n    }\\n\\n    function convertAddyToNum(address a) internal pure returns (uint256) {\\n        return uint256(uint160(a));\\n    }\\n\\n    function convertNumToAddy(uint256 a) internal pure returns (address) {\\n        return address(uint160(a));\\n    }\\n\\n    function testDecodePacked(\\n        bytes memory packed\\n    ) internal pure returns (bytes5 info, bytes memory) {\\n        assembly {\\n            info := mload(add(packed, INSTRUCTION_LENGTH))\\n        }\\n        bytes memory newArray;\\n        for (uint256 i = 0; i < packed.length - 5; i++) {\\n            newArray = abi.encodePacked(newArray, packed[i + 5]);\\n        }\\n        // Trim the array by reducing its length\\n        return (info, newArray);\\n    }\\n\\n    function addDataToFront(\\n        uint256[] memory data,\\n        bytes memory packedInfo\\n    ) internal pure returns (bytes memory packedResult) {\\n        packedResult = packedInfo;\\n        packedResult = abi.encode(data, packedInfo);\\n    }\\n\\n    function readData(\\n        bytes memory data\\n    ) internal pure returns (uint256[] memory, bytes memory) {\\n        return abi.decode(data, (uint256[], bytes));\\n    }\\n\\n    function executeInstruction(\\n        uint256[] memory inputs,\\n        bytes5 instruction\\n    ) internal returns (uint256[] memory) {\\n        (\\n            bytes4 selector,\\n            uint8 inputCount,\\n            uint8 outputCount\\n        ) = parseInstruction(instruction);\\n        bytes memory data;\\n        bool success;\\n        if (inputCount == 0) {\\n            (success, data) = address(this).call(\\n                abi.encodeWithSelector(selector)\\n            );\\n        } else {\\n            (success, data) = address(this).call(\\n                abi.encodeWithSelector(selector, inputs)\\n            );\\n        }\\n        if (outputCount == 0) {\\n            uint256[] memory newArray = new uint256[](1);\\n            newArray[0] = 0;\\n\\n            return newArray;\\n        }\\n        if (outputCount == 1) {\\n            uint256 outPut1 = abi.decode(data, (uint256));\\n            uint256[] memory newArray = new uint256[](outputCount);\\n\\n            newArray[0] = outPut1;\\n\\n            return newArray;\\n        }\\n        if (outputCount == 2) {\\n            console.log(\\\"Before\\\");\\n            (uint256 outPut1, uint256 outPut2) = abi.decode(\\n                data,\\n                (uint256, uint256)\\n            );\\n            console.log(outPut1, outPut2);\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            return newArray;\\n        }\\n        if (outputCount == 3) {\\n            (uint256 outPut1, uint256 outPut2, uint256 outPut3) = abi.decode(\\n                data,\\n                (uint256, uint256, uint256)\\n            );\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            newArray[2] = outPut3;\\n            return newArray;\\n        }\\n        if (outputCount == 4) {\\n            (\\n                uint256 outPut1,\\n                uint256 outPut2,\\n                uint256 outPut3,\\n                uint256 outPut4\\n            ) = abi.decode(data, (uint256, uint256, uint256, uint256));\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            newArray[2] = outPut3;\\n            newArray[3] = outPut4;\\n            return newArray;\\n        }\\n        if (outputCount == 5) {\\n            (\\n                uint256 outPut1,\\n                uint256 outPut2,\\n                uint256 outPut3,\\n                uint256 outPut4,\\n                uint256 outPut5\\n            ) = abi.decode(data, (uint256, uint256, uint256, uint256, uint256));\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            newArray[2] = outPut3;\\n            newArray[3] = outPut4;\\n            newArray[4] = outPut5;\\n            return newArray;\\n        }\\n        if (outputCount == 6) {\\n            (\\n                uint256 outPut1,\\n                uint256 outPut2,\\n                uint256 outPut3,\\n                uint256 outPut4,\\n                uint256 outPut5,\\n                uint256 outPut6\\n            ) = abi.decode(\\n                    data,\\n                    (uint256, uint256, uint256, uint256, uint256, uint256)\\n                );\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            newArray[2] = outPut3;\\n            newArray[3] = outPut4;\\n            newArray[4] = outPut5;\\n            newArray[6] = outPut6;\\n\\n            return newArray;\\n        }\\n    }\\n\\n    function parseInstruction(\\n        bytes5 data\\n    ) internal pure returns (bytes4 selector, uint8 inp, uint8 out) {\\n        // Extract the first 4 bytes (selector)\\n        selector = (bytes4(data));\\n\\n        bytes1 describer = data[4];\\n        inp = uint8(describer >> 4); // Shift 4 bits to the right to isolate the first 4 bits (1)\\n        out = uint8(describer & 0x0F);\\n    }\\n\\n    function startWorking(\\n        bytes memory dataFlow\\n    ) internal returns (uint256[] memory finalOutputs) {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.work = true;\\n        managerState.executionOccuring = true;\\n\\n        (uint256[] memory inputs, bytes memory packedInstructions) = readData(\\n            dataFlow\\n        );\\n\\n        bytes5 instruction;\\n        (instruction, dataFlow) = testDecodePacked(packedInstructions);\\n        managerState.currentDataFlow = dataFlow;\\n        finalOutputs = executeInstruction(inputs, instruction);\\n\\n        if (dataFlow.length < 3 || !managerState.work) {\\n            managerState.lastResult = finalOutputs;\\n            managerState.executionOccuring = false;\\n            return finalOutputs;\\n        }\\n        dataFlow = addDataToFront(finalOutputs, dataFlow);\\n        startWorking(dataFlow);\\n    }\\n\\n    function startWorkingFromID(\\n        uint256 ID\\n    ) internal returns (uint256[] memory finalOutputs) {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.work = true;\\n        managerState.executionOccuring = true;\\n\\n        bytes memory dataFlow = managerState.userFlows[ID].dataFlow;\\n        (uint256[] memory inputs, bytes memory packedInstructions) = readData(\\n            dataFlow\\n        );\\n\\n        bytes5 instruction;\\n        (instruction, dataFlow) = testDecodePacked(packedInstructions);\\n        finalOutputs = executeInstruction(inputs, instruction);\\n\\n        if (dataFlow.length < 3 || !managerState.work) {\\n            console.log(finalOutputs[0], finalOutputs[1]);\\n            managerState.lastResult = finalOutputs;\\n            console.log(finalOutputs.length);\\n            managerState.executionOccuring = false;\\n            return finalOutputs;\\n        }\\n        dataFlow = addDataToFront(finalOutputs, dataFlow);\\n        startWorking(dataFlow);\\n    }\\n\\n    function getLastResult(uint256 index) internal view returns (uint256) {\\n        ManagerState storage managerState = diamondStorage();\\n        return managerState.lastResult[index];\\n    }\\n\\n    function parseLastResultAndExecute(\\n        bytes memory dataFlow,\\n        uint256 index\\n    ) internal returns (uint256) {\\n        startWorking(dataFlow);\\n        return getLastResult(index);\\n    }\\n\\n    function createNewFlow(\\n        address user,\\n        string memory description,\\n        bytes memory dataFlow\\n    ) internal returns (uint256) {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.userFlows[managerState.flowID] = flowGraph({\\n            description: description,\\n            dataFlow: dataFlow\\n        });\\n\\n        managerState.userIds[user].push(managerState.flowID);\\n        managerState.flowID++;\\n        return managerState.flowID - 1;\\n    }\\n\\n    function createNewHookFlow(\\n        address user,\\n        string memory description,\\n        bytes memory dataFlow\\n    ) internal returns (uint256) {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.userFlows[managerState.flowID] = flowGraph({\\n            description: description,\\n            dataFlow: dataFlow\\n        });\\n        managerState.afterSwapFlows.push(dataFlow);\\n        managerState.userIds[user].push(managerState.flowID);\\n        managerState.flowID++;\\n        return managerState.flowID - 1;\\n    }\\n\\n    function getCurrentFlow() internal view returns (bytes memory) {\\n        ManagerState storage managerState = diamondStorage();\\n        return managerState.currentDataFlow;\\n    }\\n\\n    function stopExecution() internal {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.work = false;\\n    }\\n\\n    function transferEtherToCaller() public {\\n        require(address(this).balance > 0, \\\"Contract has no Ether to transfer\\\");\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    function transferTokenToCaller(address tokenAddy, uint256 amount) public {\\n        IERC20 token = IERC20(tokenAddy);\\n        require(\\n            token.balanceOf(address(this)) >= amount,\\n            \\\"Contract has insufficient tokens\\\"\\n        );\\n        token.transfer(msg.sender, amount);\\n    }\\n}\\n\\ncontract ManagerFacet {\\n    function getLastResult(uint256 index) external view returns (uint256) {\\n        return ManagerLib.getLastResult(index);\\n    }\\n\\n    function parseLastResultAndExecute(\\n        bytes memory dataFlow,\\n        uint256 index\\n    ) external returns (uint256) {\\n        return ManagerLib.parseLastResultAndExecute(dataFlow, index);\\n    }\\n\\n    function convertBytes5ArrayToBytes(\\n        bytes5[] memory data\\n    ) external pure returns (bytes memory res) {\\n        return ManagerLib.convertBytes5ArrayToBytes(data);\\n    }\\n\\n    function convertAddyToNum(address a) external pure returns (uint256) {\\n        return ManagerLib.convertAddyToNum(a);\\n    }\\n\\n    function convertNumToAddy(uint256 a) external pure returns (address) {\\n        return ManagerLib.convertNumToAddy(a);\\n    }\\n\\n    function testDecodePacked(\\n        bytes memory packed\\n    ) external pure returns (bytes5 info, bytes memory) {\\n        return ManagerLib.testDecodePacked(packed);\\n    }\\n\\n    function addDataToFront(\\n        uint256[] memory data,\\n        bytes memory packedInfo\\n    ) external pure returns (bytes memory packedResult) {\\n        return ManagerLib.addDataToFront(data, packedInfo);\\n    }\\n\\n    function readData(\\n        bytes memory data\\n    ) external pure returns (uint256[] memory, bytes memory) {\\n        return ManagerLib.readData(data);\\n    }\\n\\n    function executeInstruction(\\n        uint256[] memory inputs,\\n        bytes5 instruction\\n    ) external returns (uint256[] memory outPuts) {\\n        return ManagerLib.executeInstruction(inputs, instruction);\\n    }\\n\\n    function parseInstruction(\\n        bytes5 data\\n    ) external pure returns (bytes4 selector, uint8 inp, uint8 out) {\\n        return ManagerLib.parseInstruction(data);\\n    }\\n\\n    function startWorking(\\n        bytes memory dataFlow\\n    ) external returns (uint256[] memory finalOutputs) {\\n        return ManagerLib.startWorking(dataFlow);\\n    }\\n\\n    function startWorkingFromID(\\n        uint256 id\\n    ) external returns (uint256[] memory finalOutputs) {\\n        return ManagerLib.startWorkingFromID(id);\\n    }\\n\\n    function createNewFlow(\\n        string memory description,\\n        bytes memory dataFlow\\n    ) external {\\n        ManagerLib.createNewFlow(tx.origin, description, dataFlow);\\n    }\\n\\n    function createNewHookFlow(\\n        string memory description,\\n        bytes memory dataFlow\\n    ) external {\\n        ManagerLib.createNewHookFlow(tx.origin, description, dataFlow);\\n    }\\n\\n    function getCurrentFlow() external view returns (bytes memory) {\\n        return ManagerLib.getCurrentFlow();\\n    }\\n\\n    function stopExecution() external {\\n        ManagerLib.stopExecution();\\n    }\\n\\n    function transferEtherToCaller() external {\\n        require(address(this).balance > 0, \\\"Contract has no Ether to transfer\\\");\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    function transferTokenToCaller(address tokenAddy, uint256 amount) external {\\n        IERC20 token = IERC20(tokenAddy);\\n        require(\\n            token.balanceOf(address(this)) >= amount,\\n            \\\"Contract has insufficient tokens\\\"\\n        );\\n        token.transfer(msg.sender, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xdeaeeec49fed6a725339ae2666ccffc89d68c04ec5a6eb7b6760419b0951ea79\",\"license\":\"MIT\"},\"contracts/Facets/UMAFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"UMA/packages/core/contracts/optimistic-oracle-v3/interfaces/OptimisticOracleV3Interface.sol\\\";\\nimport \\\"UMA/packages/core/contracts/optimistic-oracle-v3/implementation/ClaimData.sol\\\";\\nimport {SafeERC20} from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\n\\nlibrary UMALib {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.umaUMAumaUma.storage\\\");\\n    struct DataAssertion {\\n        bytes32 dataId; // The dataId that was asserted.\\n        bytes32 data; // This could be an arbitrary data type.\\n        address asserter; // The address that made the assertion.\\n        bool resolved; // Whether the assertion has been resolved.\\n    }\\n    uint64 public constant assertionLiveness = 60;\\n\\n    struct UMAState {\\n        OptimisticOracleV3Interface oov3;\\n        mapping(bytes32 => DataAssertion) assertionsData;\\n        bytes32[] assertionIDs;\\n        mapping(bytes32 => bytes32) messageToAssertionID;\\n        bytes32 defaultIdentifier;\\n        address currency;\\n    }\\n\\n    function diamondStorage() internal pure returns (UMAState storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function setOOV3(address optimisticAddress) internal {\\n        UMAState storage umaState = diamondStorage();\\n        umaState.oov3 = OptimisticOracleV3Interface(optimisticAddress);\\n        umaState.defaultIdentifier = umaState.oov3.defaultIdentifier();\\n    }\\n\\n    function setCurrency(address token) internal {\\n        UMAState storage umaState = diamondStorage();\\n        umaState.currency = token;\\n    }\\n\\n    function getData(\\n        bytes32 assertionId\\n    ) internal view returns (bool, bytes32) {\\n        UMAState storage umaState = diamondStorage();\\n\\n        if (!umaState.assertionsData[assertionId].resolved) return (false, 0);\\n        return (true, umaState.assertionsData[assertionId].data);\\n    }\\n\\n    function getAssertionID(uint256 index) internal view returns (bytes32) {\\n        UMAState storage umaState = diamondStorage();\\n        return umaState.assertionIDs[index];\\n    }\\n\\n    function assertDataFor(\\n        bytes32 dataId,\\n        bytes32 hyperlaneMessage,\\n        address asserter\\n    ) internal returns (bytes32 assertionId) {\\n        UMAState storage umaState = diamondStorage();\\n\\n        asserter = asserter == address(0) ? msg.sender : asserter;\\n        console.log(umaState.currency);\\n        uint256 bond = umaState.oov3.getMinimumBond(umaState.currency);\\n        SafeERC20.safeTransferFrom(\\n            IERC20(umaState.currency),\\n            msg.sender,\\n            address(this),\\n            bond\\n        );\\n        SafeERC20.safeApprove(\\n            IERC20(umaState.currency),\\n            address(umaState.oov3),\\n            bond\\n        );\\n\\n        // The claim we want to assert is the first argument of assertTruth. It must contain all of the relevant\\n        // details so that anyone may verify the claim without having to read any further information on chain. As a\\n        // result, the claim must include both the data id and data, as well as a set of instructions that allow anyone\\n        // to verify the information in publicly available sources.\\n        // See the UMIP corresponding to the defaultIdentifier used in the OptimisticOracleV3 \\\"ASSERT_TRUTH\\\" for more\\n        // information on how to construct the claim.\\n        assertionId = umaState.oov3.assertTruth(\\n            abi.encodePacked(\\n                \\\"Data asserted: 0x\\\", // in the example data is type bytes32 so we add the hex prefix 0x.\\n                ClaimData.toUtf8Bytes(hyperlaneMessage),\\n                \\\" for dataId: 0x\\\",\\n                ClaimData.toUtf8Bytes(dataId),\\n                \\\" and asserter: 0x\\\",\\n                ClaimData.toUtf8BytesAddress(asserter),\\n                \\\" at timestamp: \\\",\\n                ClaimData.toUtf8BytesUint(block.timestamp),\\n                \\\" in the DataAsserter contract at 0x\\\",\\n                ClaimData.toUtf8BytesAddress(address(this)),\\n                \\\" is valid.\\\"\\n            ),\\n            asserter,\\n            address(this),\\n            address(0), // No sovereign security.\\n            assertionLiveness,\\n            IERC20(umaState.currency),\\n            bond,\\n            umaState.defaultIdentifier,\\n            bytes32(0) // No domain.\\n        );\\n        umaState.assertionsData[assertionId] = DataAssertion(\\n            dataId,\\n            hyperlaneMessage,\\n            asserter,\\n            false\\n        );\\n        umaState.assertionIDs.push(assertionId);\\n    }\\n\\n    function settleAndGetAssertionResult(\\n        bytes32 assertionID\\n    ) internal returns (bool) {\\n        UMAState storage umaState = diamondStorage();\\n        if (!umaState.assertionsData[assertionID].resolved) {\\n            bool result = umaState.oov3.settleAndGetAssertionResult(\\n                assertionID\\n            );\\n            umaState.assertionsData[assertionID].resolved = result;\\n            return result;\\n        }\\n        return true;\\n    }\\n\\n    // OptimisticOracleV3 resolve callback.\\n    function assertionResolvedCallback(\\n        bytes32 assertionId,\\n        bool assertedTruthfully\\n    ) internal {\\n        UMAState storage umaState = diamondStorage();\\n\\n        require(msg.sender == address(umaState.oov3));\\n        // If the assertion was true, then the data assertion is resolved.\\n        if (assertedTruthfully) {\\n            umaState.assertionsData[assertionId].resolved = true;\\n            DataAssertion memory dataAssertion = umaState.assertionsData[\\n                assertionId\\n            ];\\n\\n            // Else delete the data assertion if it was false to save gas.\\n        } else delete umaState.assertionsData[assertionId];\\n    }\\n\\n    // If assertion is disputed, do nothing and wait for resolution.\\n    // This OptimisticOracleV3 callback function needs to be defined so the OOv3 doesn't revert when it tries to call it.\\n}\\n\\ncontract UMAFacet {\\n    function setOOV3(address optimisticAddress) external {\\n        UMALib.setOOV3(optimisticAddress);\\n    }\\n\\n    function setCurrency(address token) external {\\n        UMALib.setCurrency(token);\\n    }\\n\\n    function getData(\\n        bytes32 assertionId\\n    ) external view returns (bool, bytes32) {\\n        return UMALib.getData(assertionId);\\n    }\\n\\n    function assertDataFor(\\n        bytes32 dataId,\\n        bytes32 data,\\n        address asserter\\n    ) external returns (bytes32 assertionId) {\\n        return UMALib.assertDataFor(dataId, data, asserter);\\n    }\\n\\n    function getAssertionID(uint256 index) external view returns (bytes32) {\\n        return UMALib.getAssertionID(index);\\n    }\\n\\n    // OptimisticOracleV3 resolve callback.\\n    function assertionResolvedCallback(\\n        bytes32 assertionId,\\n        bool assertedTruthfully\\n    ) external {\\n        return\\n            UMALib.assertionResolvedCallback(assertionId, assertedTruthfully);\\n    }\\n\\n    function settleAndGetAssertionResult(\\n        bytes32 assertionID\\n    ) external returns (bool) {\\n        return UMALib.settleAndGetAssertionResult(assertionID);\\n    }\\n\\n    // If assertion is disputed, do nothing and wait for resolution.\\n    // This OptimisticOracleV3 callback function needs to be defined so the OOv3 doesn't revert when it tries to call it.\\n    function assertionDisputedCallback(bytes32 assertionId) external {}\\n}\\n\",\"keccak256\":\"0x73739c1d6b506da90bc4e36908c006450afc1919c15ec8bbb7746765104ed42c\",\"license\":\"MIT\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50611b56806100206000396000f3fe6080604052600436106100ce5760003560e01c8063125a2eca146100d35780632c2cd749146100f557806336da5fde1461011557806337e935fb146101355780633bdfa826146101485780633c84448c1461017e57806346b1a3421461019e578063476c94cd146101b357806356d5d475146101d3578063645bdfce146101f35780636465e69f14610213578063759524ed1461022f5780638ada066e1461024f578063b0cbd4d614610272578063cc4c515d14610292578063de523cf3146102b2578063f7e83aee146102c5575b600080fd5b3480156100df57600080fd5b506100f36100ee36600461140d565b6102f5565b005b34801561010157600080fd5b506100f36101103660046114e6565b610301565b34801561012157600080fd5b506100f361013036600461140d565b61030a565b6100f3610143366004611515565b610313565b34801561015457600080fd5b50610168610163366004611548565b610323565b6040516101759190611561565b60405180910390f35b34801561018a57600080fd5b506100f361019936600461140d565b610334565b3480156101aa57600080fd5b5061016861033d565b3480156101bf57600080fd5b506100f36101ce36600461140d565b61034c565b3480156101df57600080fd5b506100f36101ee3660046115bd565b610355565b3480156101ff57600080fd5b506100f361020e36600461140d565b610363565b34801561021f57600080fd5b5060405160068152602001610175565b34801561023b57600080fd5b506100f361024a3660046114e6565b61036c565b34801561025b57600080fd5b50610264610375565b604051908152602001610175565b34801561027e57600080fd5b5061026461028d366004611616565b61037f565b34801561029e57600080fd5b506100f36102ad366004611640565b610392565b3480156102be57600080fd5b5030610168565b3480156102d157600080fd5b506102e56102e036600461166c565b6103a0565b6040519015158152602001610175565b6102fe816103b9565b50565b6102fe816103fc565b6102fe81610428565b61031e838383610439565b505050565b600061032e8261057b565b92915050565b6102fe816105a4565b60006103476105b7565b905090565b6102fe816105d5565b61035d6105e8565b50505050565b6102fe8161060d565b6102fe81610620565b600061034761064f565b600061038b8383610664565b9392505050565b61039c82826106f6565b5050565b60006103ae85858585610730565b90505b949350505050565b606460006103ca82620493e0610664565b905060006103d66107c2565b905060006103e48583610897565b90506103f584620493e085846108c3565b5050505050565b6000610406610a08565b80546001600160a01b0319166001600160a01b03939093169290921790915550565b600560006103ca82620493e0610664565b6000610443610a08565b8054600182015463ffffffff871660009081526002840160205260408120549394506001600160a01b039283169391831692909116908363fa31de018961048985610a2c565b3360405160200161049a9190611561565b6040516020818303038152906040526040518463ffffffff1660e01b81526004016104c79392919061171b565b6020604051808303816000875af11580156104e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050a9190611740565b9050826001600160a01b03166311bf2c1887838b8b336040518663ffffffff1660e01b815260040161053f9493929190611759565b6000604051808303818588803b15801561055857600080fd5b505af115801561056c573d6000803e3d6000fd5b50505050505050505050505050565b600080610586610a08565b6000938452600201602052505060409020546001600160a01b031690565b62066eed60006103ca82620493e0610664565b6000806105c2610a08565b600101546001600160a01b031692915050565b6201388160006103ca82620493e0610664565b60006105f2610a08565b9050806003015460016106059190611799565b600390910155565b62014a3360006103ca82620493e0610664565b600061062a610a08565b60010180546001600160a01b0319166001600160a01b03939093169290921790915550565b60008061065a610a08565b6003015492915050565b60008061066f610a08565b600181015460405163a692979360e01b815263ffffffff87166004820152602481018690529192506001600160a01b031690819063a692979390604401602060405180830381865afa1580156106c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ed9190611740565b95945050505050565b6000610700610a08565b600093845260020160205250604090912080546001600160a01b0319166001600160a01b03909216919091179055565b60008061073b610a08565b90506000610747610a38565b9050600182600301600082825461075e9190611799565b909155505080546001600160a01b0316156107b5576003820154600061078e82610788888a6117ac565b30610a5c565b9050806003840160006107a1898b6117ac565b815260208101919091526040016000205550505b5060019695505050505050565b7f4bc1672041418a922447d83c0efd37e6707ed20ab7e53ca3f20ce1d16cac307c80546060917f4bc1672041418a922447d83c0efd37e6707ed20ab7e53ca3f20ce1d16cac307591610813906117ca565b80601f016020809104026020016040519081016040528092919081815260200182805461083f906117ca565b801561088c5780601f106108615761010080835404028352916020019161088c565b820191906000526020600020905b81548152906001019060200180831161086f57829003601f168201915b505050505091505090565b60405181906108ac9084908390602001611804565b604051602081830303815290604052905092915050565b60006108cd610a08565b8054600182015463ffffffff881660009081526002840160205260408120549394506001600160a01b039283169391831692909116908363fa31de018a61091385610a2c565b338a60405160200161092692919061185b565b6040516020818303038152906040526040518463ffffffff1660e01b81526004016109539392919061171b565b6020604051808303816000875af1158015610972573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109969190611740565b9050826001600160a01b03166311bf2c1888838c8c336040518663ffffffff1660e01b81526004016109cb9493929190611759565b6000604051808303818588803b1580156109e457600080fd5b505af11580156109f8573d6000803e3d6000fd5b5050505050505050505050505050565b7f34fbc1afd8e1b9169b38b6c80a52777e06873abc0d2b3f992f7608bdf1bf6ade90565b6001600160a01b031690565b7f16649c8924f5903fda94e8001436d5b66bc9e9a70208d5245edfc147a57b508690565b600080610a67610a38565b90506001600160a01b03831615610a7e5782610a80565b335b6005820154909350610a9a906001600160a01b0316610cc1565b80546005820154604051634360af3d60e01b81526000926001600160a01b0390811692634360af3d92610ad39290911690600401611561565b602060405180830381865afa158015610af0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b149190611740565b6005830154909150610b31906001600160a01b0316333084610d04565b60058201548254610b4f916001600160a01b03908116911683610d6f565b81546001600160a01b0316636457c979610b6887610e89565b610b7189610e89565b610b7a88610eca565b610b8342610f1c565b610b8c30610eca565b604051602001610ba095949392919061189b565b60408051601f198184030181529082905260058601546004808801546001600160e01b031960e087901b168552610bf1948b933093600093603c936001600160a01b03909316928c928691016119b8565b6020604051808303816000875af1158015610c10573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c349190611740565b6040805160808101825297885260208089019788526001600160a01b03968716898301908152600060608b01818152858252600188810185529482209b518c5599518b850155905160029a8b0180549a511515600160a01b026001600160a81b0319909b169190991617989098179096559690920180549687018155855250919092209092018290555090565b6102fe81604051602401610cd59190611561565b60408051601f198184030181529190526020810180516001600160e01b031663161765e160e11b179052611047565b6040516001600160a01b038085166024830152831660448201526064810182905261035d9085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611050565b801580610de95750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015610dc3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de79190611740565b155b610e595760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084015b60405180910390fd5b6040516001600160a01b03831660248201526044810182905261031e90849063095ea7b360e01b90606401610d38565b6060610e98608083901c611125565b610ea183611125565b6040805160208101939093528201526060015b6040516020818303038152906040529050919050565b6060610ee26001600160801b03602084901c16611125565b610ef88360601b6001600160601b031916611125565b604051602001610eb49291909182526001600160c01b031916602082015260280190565b606081600003610f435750506040805180820190915260018152600360fc1b602082015290565b8160005b8115610f6d5780610f5781611a25565b9150610f669050600a83611a54565b9150610f47565b6000816001600160401b03811115610f8757610f876113f7565b6040519080825280601f01601f191660200182016040528015610fb1576020820181803683370190505b509050815b851561103e57610fc7600182611a76565b90506000610fd6600a88611a54565b610fe190600a611a89565b610feb9088611a76565b610ff6906030611aa0565b905060008160f81b90508084848151811061101357611013611ab9565b60200101906001600160f81b031916908160001a905350611035600a89611a54565b97505050610fb6565b50949350505050565b6102fe816112b3565b60006110a5826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166112d49092919063ffffffff16565b90508051600014806110c65750808060200190518101906110c69190611acf565b61031e5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610e50565b6000808260001c9050806001600160801b0316905080600160401b0281176001600160401b03600160801b03600160c01b0316905080600160201b0281177bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16905080620100000281177dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff169050806101000281177eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff1690508060100281177f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f16905060006008827f0808080808080808080808080808080808080808080808080808080808080808168161123557611235611a3e565b0460047f040404040404040404040404040404040404040404040404040404040404040484160460027f020202020202020202020202020202020202020202020202020202020202020285160417166027029091017f3030303030303030303030303030303030303030303030303030303030303030019392505050565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b60606103b1848460008585600080866001600160a01b031685876040516112fb9190611af1565b60006040518083038185875af1925050503d8060008114611338576040519150601f19603f3d011682016040523d82523d6000602084013e61133d565b606091505b509150915061134e87838387611359565b979650505050505050565b606083156113c85782516000036113c1576001600160a01b0385163b6113c15760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610e50565b50816103b1565b6103b183838151156113dd5781518083602001fd5b8060405162461bcd60e51b8152600401610e509190611b0d565b634e487b7160e01b600052604160045260246000fd5b6000602080838503121561142057600080fd5b82356001600160401b038082111561143757600080fd5b818501915085601f83011261144b57600080fd5b81358181111561145d5761145d6113f7565b8060051b604051601f19603f83011681018181108582111715611482576114826113f7565b6040529182528482019250838101850191888311156114a057600080fd5b938501935b828510156114be578435845293850193928501926114a5565b98975050505050505050565b80356001600160a01b03811681146114e157600080fd5b919050565b6000602082840312156114f857600080fd5b61038b826114ca565b803563ffffffff811681146114e157600080fd5b60008060006060848603121561152a57600080fd5b61153384611501565b95602085013595506040909401359392505050565b60006020828403121561155a57600080fd5b5035919050565b6001600160a01b0391909116815260200190565b60008083601f84011261158757600080fd5b5081356001600160401b0381111561159e57600080fd5b6020830191508360208285010111156115b657600080fd5b9250929050565b600080600080606085870312156115d357600080fd5b6115dc85611501565b93506020850135925060408501356001600160401b038111156115fe57600080fd5b61160a87828801611575565b95989497509550505050565b6000806040838503121561162957600080fd5b61163283611501565b946020939093013593505050565b6000806040838503121561165357600080fd5b82359150611663602084016114ca565b90509250929050565b6000806000806040858703121561168257600080fd5b84356001600160401b038082111561169957600080fd5b6116a588838901611575565b909650945060208701359150808211156116be57600080fd5b5061160a87828801611575565b60005b838110156116e65781810151838201526020016116ce565b50506000910152565b600081518084526117078160208601602086016116cb565b601f01601f19169290920160200192915050565b63ffffffff841681528260208201526060604082015260006103ae60608301846116ef565b60006020828403121561175257600080fd5b5051919050565b93845263ffffffff92909216602084015260408301526001600160a01b0316606082015260800190565b634e487b7160e01b600052601160045260246000fd5b8082018082111561032e5761032e611783565b8035602083101561032e57600019602084900360031b1b1692915050565b600181811c908216806117de57607f821691505b6020821081036117fe57634e487b7160e01b600052602260045260246000fd5b50919050565b604080825283519082018190526000906020906060840190828701845b8281101561183d57815184529284019290840190600101611821565b5050508381038285015261185181866116ef565b9695505050505050565b6001600160a01b03831681526040602082018190526000906103b1908301846116ef565b600081516118918185602086016116cb565b9290920192915050565b70088c2e8c240c2e6e6cae4e8cac8744060f607b1b81526000865160206118c88260118601838c016116cb565b6e040ccdee440c8c2e8c292c8744060f608b1b60119285019283015287516118f581838501848c016116cb565b70040c2dcc840c2e6e6cae4e8cae4744060f607b1b920181810192909252865161192581603185018a85016116cb565b6011818401019250506e01030ba103a34b6b2b9ba30b6b81d1608d1b81830152855161195781602f8501848a016116cb565b600f818401019250507f20696e207468652044617461417373657274657220636f6e747261637420617481830152506204060f60eb1b60408201526114be6119a2604383018661187f565b691034b9903b30b634b21760b11b8152600a0190565b60006101208083526119cc8184018d6116ef565b6001600160a01b039b8c166020850152998b166040840152505095881660608701526001600160401b039490941660808601529190951660a084015260c083019490945260e08201939093526101000191909152919050565b600060018201611a3757611a37611783565b5060010190565b634e487b7160e01b600052601260045260246000fd5b600082611a7157634e487b7160e01b600052601260045260246000fd5b500490565b8181038181111561032e5761032e611783565b808202811582820484141761032e5761032e611783565b60ff818116838216019081111561032e5761032e611783565b634e487b7160e01b600052603260045260246000fd5b600060208284031215611ae157600080fd5b8151801515811461038b57600080fd5b60008251611b038184602087016116cb565b9190910192915050565b60208152600061038b60208301846116ef56fea2646970667358221220baabf5775c960089599cc032f79dda16801539294b96b3a645486b67f032252564736f6c63430008140033",
  "deployedBytecode": "0x6080604052600436106100ce5760003560e01c8063125a2eca146100d35780632c2cd749146100f557806336da5fde1461011557806337e935fb146101355780633bdfa826146101485780633c84448c1461017e57806346b1a3421461019e578063476c94cd146101b357806356d5d475146101d3578063645bdfce146101f35780636465e69f14610213578063759524ed1461022f5780638ada066e1461024f578063b0cbd4d614610272578063cc4c515d14610292578063de523cf3146102b2578063f7e83aee146102c5575b600080fd5b3480156100df57600080fd5b506100f36100ee36600461140d565b6102f5565b005b34801561010157600080fd5b506100f36101103660046114e6565b610301565b34801561012157600080fd5b506100f361013036600461140d565b61030a565b6100f3610143366004611515565b610313565b34801561015457600080fd5b50610168610163366004611548565b610323565b6040516101759190611561565b60405180910390f35b34801561018a57600080fd5b506100f361019936600461140d565b610334565b3480156101aa57600080fd5b5061016861033d565b3480156101bf57600080fd5b506100f36101ce36600461140d565b61034c565b3480156101df57600080fd5b506100f36101ee3660046115bd565b610355565b3480156101ff57600080fd5b506100f361020e36600461140d565b610363565b34801561021f57600080fd5b5060405160068152602001610175565b34801561023b57600080fd5b506100f361024a3660046114e6565b61036c565b34801561025b57600080fd5b50610264610375565b604051908152602001610175565b34801561027e57600080fd5b5061026461028d366004611616565b61037f565b34801561029e57600080fd5b506100f36102ad366004611640565b610392565b3480156102be57600080fd5b5030610168565b3480156102d157600080fd5b506102e56102e036600461166c565b6103a0565b6040519015158152602001610175565b6102fe816103b9565b50565b6102fe816103fc565b6102fe81610428565b61031e838383610439565b505050565b600061032e8261057b565b92915050565b6102fe816105a4565b60006103476105b7565b905090565b6102fe816105d5565b61035d6105e8565b50505050565b6102fe8161060d565b6102fe81610620565b600061034761064f565b600061038b8383610664565b9392505050565b61039c82826106f6565b5050565b60006103ae85858585610730565b90505b949350505050565b606460006103ca82620493e0610664565b905060006103d66107c2565b905060006103e48583610897565b90506103f584620493e085846108c3565b5050505050565b6000610406610a08565b80546001600160a01b0319166001600160a01b03939093169290921790915550565b600560006103ca82620493e0610664565b6000610443610a08565b8054600182015463ffffffff871660009081526002840160205260408120549394506001600160a01b039283169391831692909116908363fa31de018961048985610a2c565b3360405160200161049a9190611561565b6040516020818303038152906040526040518463ffffffff1660e01b81526004016104c79392919061171b565b6020604051808303816000875af11580156104e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061050a9190611740565b9050826001600160a01b03166311bf2c1887838b8b336040518663ffffffff1660e01b815260040161053f9493929190611759565b6000604051808303818588803b15801561055857600080fd5b505af115801561056c573d6000803e3d6000fd5b50505050505050505050505050565b600080610586610a08565b6000938452600201602052505060409020546001600160a01b031690565b62066eed60006103ca82620493e0610664565b6000806105c2610a08565b600101546001600160a01b031692915050565b6201388160006103ca82620493e0610664565b60006105f2610a08565b9050806003015460016106059190611799565b600390910155565b62014a3360006103ca82620493e0610664565b600061062a610a08565b60010180546001600160a01b0319166001600160a01b03939093169290921790915550565b60008061065a610a08565b6003015492915050565b60008061066f610a08565b600181015460405163a692979360e01b815263ffffffff87166004820152602481018690529192506001600160a01b031690819063a692979390604401602060405180830381865afa1580156106c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ed9190611740565b95945050505050565b6000610700610a08565b600093845260020160205250604090912080546001600160a01b0319166001600160a01b03909216919091179055565b60008061073b610a08565b90506000610747610a38565b9050600182600301600082825461075e9190611799565b909155505080546001600160a01b0316156107b5576003820154600061078e82610788888a6117ac565b30610a5c565b9050806003840160006107a1898b6117ac565b815260208101919091526040016000205550505b5060019695505050505050565b7f4bc1672041418a922447d83c0efd37e6707ed20ab7e53ca3f20ce1d16cac307c80546060917f4bc1672041418a922447d83c0efd37e6707ed20ab7e53ca3f20ce1d16cac307591610813906117ca565b80601f016020809104026020016040519081016040528092919081815260200182805461083f906117ca565b801561088c5780601f106108615761010080835404028352916020019161088c565b820191906000526020600020905b81548152906001019060200180831161086f57829003601f168201915b505050505091505090565b60405181906108ac9084908390602001611804565b604051602081830303815290604052905092915050565b60006108cd610a08565b8054600182015463ffffffff881660009081526002840160205260408120549394506001600160a01b039283169391831692909116908363fa31de018a61091385610a2c565b338a60405160200161092692919061185b565b6040516020818303038152906040526040518463ffffffff1660e01b81526004016109539392919061171b565b6020604051808303816000875af1158015610972573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109969190611740565b9050826001600160a01b03166311bf2c1888838c8c336040518663ffffffff1660e01b81526004016109cb9493929190611759565b6000604051808303818588803b1580156109e457600080fd5b505af11580156109f8573d6000803e3d6000fd5b5050505050505050505050505050565b7f34fbc1afd8e1b9169b38b6c80a52777e06873abc0d2b3f992f7608bdf1bf6ade90565b6001600160a01b031690565b7f16649c8924f5903fda94e8001436d5b66bc9e9a70208d5245edfc147a57b508690565b600080610a67610a38565b90506001600160a01b03831615610a7e5782610a80565b335b6005820154909350610a9a906001600160a01b0316610cc1565b80546005820154604051634360af3d60e01b81526000926001600160a01b0390811692634360af3d92610ad39290911690600401611561565b602060405180830381865afa158015610af0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b149190611740565b6005830154909150610b31906001600160a01b0316333084610d04565b60058201548254610b4f916001600160a01b03908116911683610d6f565b81546001600160a01b0316636457c979610b6887610e89565b610b7189610e89565b610b7a88610eca565b610b8342610f1c565b610b8c30610eca565b604051602001610ba095949392919061189b565b60408051601f198184030181529082905260058601546004808801546001600160e01b031960e087901b168552610bf1948b933093600093603c936001600160a01b03909316928c928691016119b8565b6020604051808303816000875af1158015610c10573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c349190611740565b6040805160808101825297885260208089019788526001600160a01b03968716898301908152600060608b01818152858252600188810185529482209b518c5599518b850155905160029a8b0180549a511515600160a01b026001600160a81b0319909b169190991617989098179096559690920180549687018155855250919092209092018290555090565b6102fe81604051602401610cd59190611561565b60408051601f198184030181529190526020810180516001600160e01b031663161765e160e11b179052611047565b6040516001600160a01b038085166024830152831660448201526064810182905261035d9085906323b872dd60e01b906084015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611050565b801580610de95750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015610dc3573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de79190611740565b155b610e595760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084015b60405180910390fd5b6040516001600160a01b03831660248201526044810182905261031e90849063095ea7b360e01b90606401610d38565b6060610e98608083901c611125565b610ea183611125565b6040805160208101939093528201526060015b6040516020818303038152906040529050919050565b6060610ee26001600160801b03602084901c16611125565b610ef88360601b6001600160601b031916611125565b604051602001610eb49291909182526001600160c01b031916602082015260280190565b606081600003610f435750506040805180820190915260018152600360fc1b602082015290565b8160005b8115610f6d5780610f5781611a25565b9150610f669050600a83611a54565b9150610f47565b6000816001600160401b03811115610f8757610f876113f7565b6040519080825280601f01601f191660200182016040528015610fb1576020820181803683370190505b509050815b851561103e57610fc7600182611a76565b90506000610fd6600a88611a54565b610fe190600a611a89565b610feb9088611a76565b610ff6906030611aa0565b905060008160f81b90508084848151811061101357611013611ab9565b60200101906001600160f81b031916908160001a905350611035600a89611a54565b97505050610fb6565b50949350505050565b6102fe816112b3565b60006110a5826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166112d49092919063ffffffff16565b90508051600014806110c65750808060200190518101906110c69190611acf565b61031e5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b6064820152608401610e50565b6000808260001c9050806001600160801b0316905080600160401b0281176001600160401b03600160801b03600160c01b0316905080600160201b0281177bffffffff00000000ffffffff00000000ffffffff00000000ffffffff16905080620100000281177dffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff0000ffff169050806101000281177eff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff00ff1690508060100281177f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f16905060006008827f0808080808080808080808080808080808080808080808080808080808080808168161123557611235611a3e565b0460047f040404040404040404040404040404040404040404040404040404040404040484160460027f020202020202020202020202020202020202020202020202020202020202020285160417166027029091017f3030303030303030303030303030303030303030303030303030303030303030019392505050565b60006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b60606103b1848460008585600080866001600160a01b031685876040516112fb9190611af1565b60006040518083038185875af1925050503d8060008114611338576040519150601f19603f3d011682016040523d82523d6000602084013e61133d565b606091505b509150915061134e87838387611359565b979650505050505050565b606083156113c85782516000036113c1576001600160a01b0385163b6113c15760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e74726163740000006044820152606401610e50565b50816103b1565b6103b183838151156113dd5781518083602001fd5b8060405162461bcd60e51b8152600401610e509190611b0d565b634e487b7160e01b600052604160045260246000fd5b6000602080838503121561142057600080fd5b82356001600160401b038082111561143757600080fd5b818501915085601f83011261144b57600080fd5b81358181111561145d5761145d6113f7565b8060051b604051601f19603f83011681018181108582111715611482576114826113f7565b6040529182528482019250838101850191888311156114a057600080fd5b938501935b828510156114be578435845293850193928501926114a5565b98975050505050505050565b80356001600160a01b03811681146114e157600080fd5b919050565b6000602082840312156114f857600080fd5b61038b826114ca565b803563ffffffff811681146114e157600080fd5b60008060006060848603121561152a57600080fd5b61153384611501565b95602085013595506040909401359392505050565b60006020828403121561155a57600080fd5b5035919050565b6001600160a01b0391909116815260200190565b60008083601f84011261158757600080fd5b5081356001600160401b0381111561159e57600080fd5b6020830191508360208285010111156115b657600080fd5b9250929050565b600080600080606085870312156115d357600080fd5b6115dc85611501565b93506020850135925060408501356001600160401b038111156115fe57600080fd5b61160a87828801611575565b95989497509550505050565b6000806040838503121561162957600080fd5b61163283611501565b946020939093013593505050565b6000806040838503121561165357600080fd5b82359150611663602084016114ca565b90509250929050565b6000806000806040858703121561168257600080fd5b84356001600160401b038082111561169957600080fd5b6116a588838901611575565b909650945060208701359150808211156116be57600080fd5b5061160a87828801611575565b60005b838110156116e65781810151838201526020016116ce565b50506000910152565b600081518084526117078160208601602086016116cb565b601f01601f19169290920160200192915050565b63ffffffff841681528260208201526060604082015260006103ae60608301846116ef565b60006020828403121561175257600080fd5b5051919050565b93845263ffffffff92909216602084015260408301526001600160a01b0316606082015260800190565b634e487b7160e01b600052601160045260246000fd5b8082018082111561032e5761032e611783565b8035602083101561032e57600019602084900360031b1b1692915050565b600181811c908216806117de57607f821691505b6020821081036117fe57634e487b7160e01b600052602260045260246000fd5b50919050565b604080825283519082018190526000906020906060840190828701845b8281101561183d57815184529284019290840190600101611821565b5050508381038285015261185181866116ef565b9695505050505050565b6001600160a01b03831681526040602082018190526000906103b1908301846116ef565b600081516118918185602086016116cb565b9290920192915050565b70088c2e8c240c2e6e6cae4e8cac8744060f607b1b81526000865160206118c88260118601838c016116cb565b6e040ccdee440c8c2e8c292c8744060f608b1b60119285019283015287516118f581838501848c016116cb565b70040c2dcc840c2e6e6cae4e8cae4744060f607b1b920181810192909252865161192581603185018a85016116cb565b6011818401019250506e01030ba103a34b6b2b9ba30b6b81d1608d1b81830152855161195781602f8501848a016116cb565b600f818401019250507f20696e207468652044617461417373657274657220636f6e747261637420617481830152506204060f60eb1b60408201526114be6119a2604383018661187f565b691034b9903b30b634b21760b11b8152600a0190565b60006101208083526119cc8184018d6116ef565b6001600160a01b039b8c166020850152998b166040840152505095881660608701526001600160401b039490941660808601529190951660a084015260c083019490945260e08201939093526101000191909152919050565b600060018201611a3757611a37611783565b5060010190565b634e487b7160e01b600052601260045260246000fd5b600082611a7157634e487b7160e01b600052601260045260246000fd5b500490565b8181038181111561032e5761032e611783565b808202811582820484141761032e5761032e611783565b60ff818116838216019081111561032e5761032e611783565b634e487b7160e01b600052603260045260246000fd5b600060208284031215611ae157600080fd5b8151801515811461038b57600080fd5b60008251611b038184602087016116cb565b9190910192915050565b60208152600061038b60208301846116ef56fea2646970667358221220baabf5775c960089599cc032f79dda16801539294b96b3a645486b67f032252564736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {},
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}