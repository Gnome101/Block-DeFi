{
  "address": "0x1936b70E1a5A2cA8eB959C799a11B173E8FF7bd1",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "NotAnEvmAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "getCounterWorm",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getLastSender",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "payload",
          "type": "bytes"
        },
        {
          "internalType": "bytes[]",
          "name": "additionalVaas",
          "type": "bytes[]"
        },
        {
          "internalType": "bytes32",
          "name": "sourceAddress",
          "type": "bytes32"
        },
        {
          "internalType": "uint16",
          "name": "sourceChain",
          "type": "uint16"
        },
        {
          "internalType": "bytes32",
          "name": "deliveryHash",
          "type": "bytes32"
        }
      ],
      "name": "receiveWormholeMessages",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "inputs",
          "type": "uint256[]"
        }
      ],
      "name": "sendFlowTokenGoerli",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "inputs",
          "type": "uint256[]"
        }
      ],
      "name": "sendFlowTokensArbG",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "inputs",
          "type": "uint256[]"
        }
      ],
      "name": "sendFlowTokensBase",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[]",
          "name": "inputs",
          "type": "uint256[]"
        }
      ],
      "name": "sendFlowTokensMumbai",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint16",
          "name": "domain",
          "type": "uint16"
        },
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "setAddyForDomain",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokeBridge",
          "type": "address"
        }
      ],
      "name": "setTokenBridge",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "wormHole",
          "type": "address"
        }
      ],
      "name": "setWormHole",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "wormRelay",
          "type": "address"
        }
      ],
      "name": "setWormRelayer",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x6c723807bcb97f7275682c998d707b1d1d5ee45ac9cde6011c7a8ad464cbb50e",
  "receipt": {
    "to": null,
    "from": "0x793448209Ef713CAe41437C7DaA219b59BEF1A4A",
    "contractAddress": "0x1936b70E1a5A2cA8eB959C799a11B173E8FF7bd1",
    "transactionIndex": 1,
    "gasUsed": "2400064",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd94cbbadd7c9466e656ebe2ff4f74375d4187ab77686f7800171bbbfa14c321d",
    "transactionHash": "0x6c723807bcb97f7275682c998d707b1d1d5ee45ac9cde6011c7a8ad464cbb50e",
    "logs": [],
    "blockNumber": 49945560,
    "cumulativeGasUsed": "2400064",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "0e22ea53b39ec09566e3f1de54c015d2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"NotAnEvmAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"getCounterWorm\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getLastSender\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"payload\",\"type\":\"bytes\"},{\"internalType\":\"bytes[]\",\"name\":\"additionalVaas\",\"type\":\"bytes[]\"},{\"internalType\":\"bytes32\",\"name\":\"sourceAddress\",\"type\":\"bytes32\"},{\"internalType\":\"uint16\",\"name\":\"sourceChain\",\"type\":\"uint16\"},{\"internalType\":\"bytes32\",\"name\":\"deliveryHash\",\"type\":\"bytes32\"}],\"name\":\"receiveWormholeMessages\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"sendFlowTokenGoerli\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"sendFlowTokensArbG\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"sendFlowTokensBase\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"sendFlowTokensMumbai\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint16\",\"name\":\"domain\",\"type\":\"uint16\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"setAddyForDomain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokeBridge\",\"type\":\"address\"}],\"name\":\"setTokenBridge\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wormHole\",\"type\":\"address\"}],\"name\":\"setWormHole\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"wormRelay\",\"type\":\"address\"}],\"name\":\"setWormRelayer\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)\":{\"params\":{\"additionalVaas\":\"- Additional VAAs which were requested to be included in this delivery.   They are guaranteed to all be included and in the same order as was specified in the     delivery request.\",\"deliveryHash\":\"- the VAA hash of the deliveryVAA. NOTE: These signedVaas are NOT verified by the Wormhole core contract prior to being provided     to this call. Always make sure `parseAndVerify()` is called on the Wormhole core contract     before trusting the content of a raw VAA, otherwise the VAA may be invalid or malicious.\",\"payload\":\"- an arbitrary message which was included in the delivery by the     requester.\",\"sourceAddress\":\"- the (wormhole format) address on the sending chain which requested     this delivery.\",\"sourceChain\":\"- the wormhole chain ID where this delivery was requested.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)\":{\"notice\":\"When a `send` is performed with this contract as the target, this function will be     invoked by the WormholeRelayer contract NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it. We also recommend that this function:   - Stores all received `deliveryHash`s in a mapping `(bytes32 => bool)`, and       on every call, checks that deliveryHash has not already been stored in the       map (This is to prevent other users maliciously trying to relay the same message)   - Checks that `sourceChain` and `sourceAddress` are indeed who       you expect to have requested the calling of `send` on the source chain The invocation of this function corresponding to the `send` request will have msg.value equal   to the receiverValue specified in the send request. If the invocation of this function reverts or exceeds the gas limit   specified by the send requester, this delivery will result in a `ReceiverFailure`.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Facets/WormFacet.sol\":\"WormFacet\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"contracts/Facets/ManagerFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\n// Example library to show a simple example of diamond storage\\nimport \\\"hardhat/console.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\nlibrary ManagerLib {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.manager.storage\\\");\\n\\n    struct ManagerState {\\n        uint256 huh;\\n        uint256[] lastResult;\\n        mapping(address => uint256[]) userIds;\\n        mapping(uint256 => flowGraph) userFlows;\\n        bytes[] afterSwapFlows;\\n        uint256 flowID;\\n        bool work;\\n        bool executionOccuring;\\n        bytes currentDataFlow;\\n    }\\n    struct flowGraph {\\n        bytes dataFlow;\\n        string description;\\n    }\\n    uint256 public constant INSTRUCTION_LENGTH = 0x20; //bytes5 type\\n\\n    function diamondStorage() internal pure returns (ManagerState storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function convertBytes5ArrayToBytes(\\n        bytes5[] memory data\\n    ) internal pure returns (bytes memory res) {\\n        for (uint i = 0; i < data.length; i++) {\\n            res = abi.encodePacked(res, data[i]);\\n        }\\n    }\\n\\n    function convertAddyToNum(address a) internal pure returns (uint256) {\\n        return uint256(uint160(a));\\n    }\\n\\n    function convertNumToAddy(uint256 a) internal pure returns (address) {\\n        return address(uint160(a));\\n    }\\n\\n    function testDecodePacked(\\n        bytes memory packed\\n    ) internal pure returns (bytes5 info, bytes memory) {\\n        assembly {\\n            info := mload(add(packed, INSTRUCTION_LENGTH))\\n        }\\n        bytes memory newArray;\\n        for (uint256 i = 0; i < packed.length - 5; i++) {\\n            newArray = abi.encodePacked(newArray, packed[i + 5]);\\n        }\\n        // Trim the array by reducing its length\\n        return (info, newArray);\\n    }\\n\\n    function addDataToFront(\\n        uint256[] memory data,\\n        bytes memory packedInfo\\n    ) internal pure returns (bytes memory packedResult) {\\n        packedResult = packedInfo;\\n        packedResult = abi.encode(data, packedInfo);\\n    }\\n\\n    function readData(\\n        bytes memory data\\n    ) internal pure returns (uint256[] memory, bytes memory) {\\n        return abi.decode(data, (uint256[], bytes));\\n    }\\n\\n    function executeInstruction(\\n        uint256[] memory inputs,\\n        bytes5 instruction\\n    ) internal returns (uint256[] memory) {\\n        (\\n            bytes4 selector,\\n            uint8 inputCount,\\n            uint8 outputCount\\n        ) = parseInstruction(instruction);\\n        bytes memory data;\\n        bool success;\\n        if (inputCount == 0) {\\n            (success, data) = address(this).call(\\n                abi.encodeWithSelector(selector)\\n            );\\n        } else {\\n            (success, data) = address(this).call(\\n                abi.encodeWithSelector(selector, inputs)\\n            );\\n        }\\n        if (outputCount == 0) {\\n            uint256[] memory newArray = new uint256[](1);\\n            newArray[0] = 0;\\n\\n            return newArray;\\n        }\\n        if (outputCount == 1) {\\n            uint256 outPut1 = abi.decode(data, (uint256));\\n            uint256[] memory newArray = new uint256[](outputCount);\\n\\n            newArray[0] = outPut1;\\n\\n            return newArray;\\n        }\\n        if (outputCount == 2) {\\n            console.log(\\\"Before\\\");\\n            (uint256 outPut1, uint256 outPut2) = abi.decode(\\n                data,\\n                (uint256, uint256)\\n            );\\n            console.log(outPut1, outPut2);\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            return newArray;\\n        }\\n        if (outputCount == 3) {\\n            (uint256 outPut1, uint256 outPut2, uint256 outPut3) = abi.decode(\\n                data,\\n                (uint256, uint256, uint256)\\n            );\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            newArray[2] = outPut3;\\n            return newArray;\\n        }\\n        if (outputCount == 4) {\\n            (\\n                uint256 outPut1,\\n                uint256 outPut2,\\n                uint256 outPut3,\\n                uint256 outPut4\\n            ) = abi.decode(data, (uint256, uint256, uint256, uint256));\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            newArray[2] = outPut3;\\n            newArray[3] = outPut4;\\n            return newArray;\\n        }\\n        if (outputCount == 5) {\\n            (\\n                uint256 outPut1,\\n                uint256 outPut2,\\n                uint256 outPut3,\\n                uint256 outPut4,\\n                uint256 outPut5\\n            ) = abi.decode(data, (uint256, uint256, uint256, uint256, uint256));\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            newArray[2] = outPut3;\\n            newArray[3] = outPut4;\\n            newArray[4] = outPut5;\\n            return newArray;\\n        }\\n        if (outputCount == 6) {\\n            (\\n                uint256 outPut1,\\n                uint256 outPut2,\\n                uint256 outPut3,\\n                uint256 outPut4,\\n                uint256 outPut5,\\n                uint256 outPut6\\n            ) = abi.decode(\\n                    data,\\n                    (uint256, uint256, uint256, uint256, uint256, uint256)\\n                );\\n            uint256[] memory newArray = new uint256[](outputCount);\\n            newArray[0] = outPut1;\\n            newArray[1] = outPut2;\\n            newArray[2] = outPut3;\\n            newArray[3] = outPut4;\\n            newArray[4] = outPut5;\\n            newArray[6] = outPut6;\\n\\n            return newArray;\\n        }\\n    }\\n\\n    function parseInstruction(\\n        bytes5 data\\n    ) internal pure returns (bytes4 selector, uint8 inp, uint8 out) {\\n        // Extract the first 4 bytes (selector)\\n        selector = (bytes4(data));\\n\\n        bytes1 describer = data[4];\\n        inp = uint8(describer >> 4); // Shift 4 bits to the right to isolate the first 4 bits (1)\\n        out = uint8(describer & 0x0F);\\n    }\\n\\n    function startWorking(\\n        bytes memory dataFlow\\n    ) internal returns (uint256[] memory finalOutputs) {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.work = true;\\n        managerState.executionOccuring = true;\\n\\n        (uint256[] memory inputs, bytes memory packedInstructions) = readData(\\n            dataFlow\\n        );\\n\\n        bytes5 instruction;\\n        (instruction, dataFlow) = testDecodePacked(packedInstructions);\\n        managerState.currentDataFlow = dataFlow;\\n        finalOutputs = executeInstruction(inputs, instruction);\\n\\n        if (dataFlow.length < 3 || !managerState.work) {\\n            managerState.lastResult = finalOutputs;\\n            managerState.executionOccuring = false;\\n            return finalOutputs;\\n        }\\n        dataFlow = addDataToFront(finalOutputs, dataFlow);\\n        startWorking(dataFlow);\\n    }\\n\\n    function startWorkingFromID(\\n        uint256 ID\\n    ) internal returns (uint256[] memory finalOutputs) {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.work = true;\\n        managerState.executionOccuring = true;\\n\\n        bytes memory dataFlow = managerState.userFlows[ID].dataFlow;\\n        (uint256[] memory inputs, bytes memory packedInstructions) = readData(\\n            dataFlow\\n        );\\n\\n        bytes5 instruction;\\n        (instruction, dataFlow) = testDecodePacked(packedInstructions);\\n        finalOutputs = executeInstruction(inputs, instruction);\\n\\n        if (dataFlow.length < 3 || !managerState.work) {\\n            console.log(finalOutputs[0], finalOutputs[1]);\\n            managerState.lastResult = finalOutputs;\\n            console.log(finalOutputs.length);\\n            managerState.executionOccuring = false;\\n            return finalOutputs;\\n        }\\n        dataFlow = addDataToFront(finalOutputs, dataFlow);\\n        startWorking(dataFlow);\\n    }\\n\\n    function getLastResult(uint256 index) internal view returns (uint256) {\\n        ManagerState storage managerState = diamondStorage();\\n        return managerState.lastResult[index];\\n    }\\n\\n    function parseLastResultAndExecute(\\n        bytes memory dataFlow,\\n        uint256 index\\n    ) internal returns (uint256) {\\n        startWorking(dataFlow);\\n        return getLastResult(index);\\n    }\\n\\n    function createNewFlow(\\n        address user,\\n        string memory description,\\n        bytes memory dataFlow\\n    ) internal returns (uint256) {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.userFlows[managerState.flowID] = flowGraph({\\n            description: description,\\n            dataFlow: dataFlow\\n        });\\n\\n        managerState.userIds[user].push(managerState.flowID);\\n        managerState.flowID++;\\n        return managerState.flowID - 1;\\n    }\\n\\n    function createNewHookFlow(\\n        address user,\\n        string memory description,\\n        bytes memory dataFlow\\n    ) internal returns (uint256) {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.userFlows[managerState.flowID] = flowGraph({\\n            description: description,\\n            dataFlow: dataFlow\\n        });\\n        managerState.afterSwapFlows.push(dataFlow);\\n        managerState.userIds[user].push(managerState.flowID);\\n        managerState.flowID++;\\n        return managerState.flowID - 1;\\n    }\\n\\n    function getCurrentFlow() internal view returns (bytes memory) {\\n        ManagerState storage managerState = diamondStorage();\\n        return managerState.currentDataFlow;\\n    }\\n\\n    function stopExecution() internal {\\n        ManagerState storage managerState = diamondStorage();\\n        managerState.work = false;\\n    }\\n\\n    function transferEtherToCaller() public {\\n        require(address(this).balance > 0, \\\"Contract has no Ether to transfer\\\");\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    function transferTokenToCaller(address tokenAddy, uint256 amount) public {\\n        IERC20 token = IERC20(tokenAddy);\\n        require(\\n            token.balanceOf(address(this)) >= amount,\\n            \\\"Contract has insufficient tokens\\\"\\n        );\\n        token.transfer(msg.sender, amount);\\n    }\\n}\\n\\ncontract ManagerFacet {\\n    function getLastResult(uint256 index) external view returns (uint256) {\\n        return ManagerLib.getLastResult(index);\\n    }\\n\\n    function parseLastResultAndExecute(\\n        bytes memory dataFlow,\\n        uint256 index\\n    ) external returns (uint256) {\\n        return ManagerLib.parseLastResultAndExecute(dataFlow, index);\\n    }\\n\\n    function convertBytes5ArrayToBytes(\\n        bytes5[] memory data\\n    ) external pure returns (bytes memory res) {\\n        return ManagerLib.convertBytes5ArrayToBytes(data);\\n    }\\n\\n    function convertAddyToNum(address a) external pure returns (uint256) {\\n        return ManagerLib.convertAddyToNum(a);\\n    }\\n\\n    function convertNumToAddy(uint256 a) external pure returns (address) {\\n        return ManagerLib.convertNumToAddy(a);\\n    }\\n\\n    function testDecodePacked(\\n        bytes memory packed\\n    ) external pure returns (bytes5 info, bytes memory) {\\n        return ManagerLib.testDecodePacked(packed);\\n    }\\n\\n    function addDataToFront(\\n        uint256[] memory data,\\n        bytes memory packedInfo\\n    ) external pure returns (bytes memory packedResult) {\\n        return ManagerLib.addDataToFront(data, packedInfo);\\n    }\\n\\n    function readData(\\n        bytes memory data\\n    ) external pure returns (uint256[] memory, bytes memory) {\\n        return ManagerLib.readData(data);\\n    }\\n\\n    function executeInstruction(\\n        uint256[] memory inputs,\\n        bytes5 instruction\\n    ) external returns (uint256[] memory outPuts) {\\n        return ManagerLib.executeInstruction(inputs, instruction);\\n    }\\n\\n    function parseInstruction(\\n        bytes5 data\\n    ) external pure returns (bytes4 selector, uint8 inp, uint8 out) {\\n        return ManagerLib.parseInstruction(data);\\n    }\\n\\n    function startWorking(\\n        bytes memory dataFlow\\n    ) external returns (uint256[] memory finalOutputs) {\\n        return ManagerLib.startWorking(dataFlow);\\n    }\\n\\n    function startWorkingFromID(\\n        uint256 id\\n    ) external returns (uint256[] memory finalOutputs) {\\n        return ManagerLib.startWorkingFromID(id);\\n    }\\n\\n    function createNewFlow(\\n        string memory description,\\n        bytes memory dataFlow\\n    ) external {\\n        ManagerLib.createNewFlow(tx.origin, description, dataFlow);\\n    }\\n\\n    function createNewHookFlow(\\n        string memory description,\\n        bytes memory dataFlow\\n    ) external {\\n        ManagerLib.createNewHookFlow(tx.origin, description, dataFlow);\\n    }\\n\\n    function getCurrentFlow() external view returns (bytes memory) {\\n        return ManagerLib.getCurrentFlow();\\n    }\\n\\n    function stopExecution() external {\\n        ManagerLib.stopExecution();\\n    }\\n\\n    function transferEtherToCaller() external {\\n        require(address(this).balance > 0, \\\"Contract has no Ether to transfer\\\");\\n        payable(msg.sender).transfer(address(this).balance);\\n    }\\n\\n    function transferTokenToCaller(address tokenAddy, uint256 amount) external {\\n        IERC20 token = IERC20(tokenAddy);\\n        require(\\n            token.balanceOf(address(this)) >= amount,\\n            \\\"Contract has insufficient tokens\\\"\\n        );\\n        token.transfer(msg.sender, amount);\\n    }\\n}\\n\",\"keccak256\":\"0xdeaeeec49fed6a725339ae2666ccffc89d68c04ec5a6eb7b6760419b0951ea79\",\"license\":\"MIT\"},\"contracts/Facets/WormFacet.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"hardhat/console.sol\\\";\\nimport \\\"../WormHole/WormholeRelayerSDK.sol\\\";\\nimport \\\"../WormHole/interfaces/IWormholeRelayer.sol\\\";\\nimport \\\"../WormHole/interfaces/ITokenBridge.sol\\\";\\nimport \\\"../WormHole/interfaces/IWormhole.sol\\\";\\n\\nimport {ManagerLib} from \\\"./ManagerFacet.sol\\\";\\n\\nlibrary WormLib {\\n    bytes32 constant DIAMOND_STORAGE_POSITION =\\n        keccak256(\\\"diamond.WORMHOLE.storage\\\");\\n    uint256 constant GAS_LIMIT = 250_000;\\n\\n    struct WormState {\\n        ITokenBridge tokenBridge;\\n        IWormhole wormHole;\\n        IWormholeRelayer wormholeRelayer;\\n        uint256 counter;\\n        address lastSender;\\n        mapping(uint16 => address) domainToAddress;\\n    }\\n\\n    function diamondStorage() internal pure returns (WormState storage ds) {\\n        bytes32 position = DIAMOND_STORAGE_POSITION;\\n        assembly {\\n            ds.slot := position\\n        }\\n    }\\n\\n    function quoteCrossChainDeposit(\\n        uint16 targetChain\\n    ) internal view returns (uint256 cost) {\\n        WormState storage wormState = diamondStorage();\\n\\n        // Cost of delivering token and payload to targetChain\\n        uint256 deliveryCost;\\n        (deliveryCost, ) = wormState.wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            0,\\n            GAS_LIMIT\\n        );\\n\\n        // Total cost: delivery cost + cost of publishing the 'sending token' wormhole message\\n        cost = deliveryCost + wormState.wormHole.messageFee();\\n    }\\n\\n    function sendCrossChainDeposit(\\n        uint16 targetChain,\\n        address recipient,\\n        uint256 amount,\\n        address token,\\n        bytes memory data\\n    ) internal {\\n        bytes memory payload = abi.encode(msg.sender, data);\\n        sendTokenWithPayloadToEvm(\\n            targetChain,\\n            recipient, // address (on targetChain) to send token and payload to\\n            payload,\\n            0, // receiver value\\n            GAS_LIMIT,\\n            token, // address of IERC20 token contract\\n            amount\\n        );\\n    }\\n\\n    function sendTokenWithPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address token,\\n        uint256 amount\\n    ) internal returns (uint64) {\\n        WormState storage wormState = diamondStorage();\\n\\n        VaaKey[] memory vaaKeys = new VaaKey[](1);\\n        vaaKeys[0] = transferTokens(token, amount, targetChain, targetAddress);\\n\\n        (uint256 cost, ) = wormState.wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            receiverValue,\\n            gasLimit\\n        );\\n        return\\n            wormState.wormholeRelayer.sendVaasToEvm{value: cost}(\\n                targetChain,\\n                targetAddress,\\n                payload,\\n                receiverValue,\\n                gasLimit,\\n                vaaKeys\\n            );\\n    }\\n\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress\\n    ) internal returns (VaaKey memory) {\\n        return\\n            transferTokens(\\n                token,\\n                amount,\\n                targetChain,\\n                targetAddress,\\n                bytes(\\\"\\\")\\n            );\\n    }\\n\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload\\n    ) internal returns (VaaKey memory) {\\n        WormState storage wormState = diamondStorage();\\n\\n        IERC20(token).approve(address(wormState.tokenBridge), amount);\\n        uint64 sequence = wormState.tokenBridge.transferTokensWithPayload{\\n            value: wormState.wormHole.messageFee()\\n        }(\\n            token,\\n            amount,\\n            targetChain,\\n            toWormholeFormat(targetAddress),\\n            0,\\n            payload\\n        );\\n        return\\n            VaaKey({\\n                emitterAddress: toWormholeFormat(\\n                    address(wormState.tokenBridge)\\n                ),\\n                chainId: wormState.wormHole.chainId(),\\n                sequence: sequence\\n            });\\n    }\\n\\n    function processRequest(\\n        bytes memory payload,\\n        TokenReceiver.TokenReceived[] memory receivedTokens,\\n        bytes32, // sourceAddress\\n        uint16,\\n        bytes32 // deliveryHash\\n    ) internal {\\n        WormState storage wormState = diamondStorage();\\n        wormState.counter++;\\n        bytes memory dataFlow;\\n        (wormState.lastSender, dataFlow) = abi.decode(\\n            payload,\\n            (address, bytes)\\n        );\\n        ManagerLib.startWorking(dataFlow);\\n    }\\n\\n    function setTokenBridge(address tokeBridge) internal {\\n        WormState storage wormState = diamondStorage();\\n        wormState.tokenBridge = ITokenBridge(tokeBridge);\\n    }\\n\\n    function setWormHole(address wormHole) internal {\\n        WormState storage wormState = diamondStorage();\\n        wormState.wormHole = IWormhole(wormHole);\\n    }\\n\\n    function setWormRelayer(address wormRelay) internal {\\n        WormState storage wormState = diamondStorage();\\n        wormState.wormholeRelayer = IWormholeRelayer(wormRelay);\\n    }\\n\\n    function setAddyForDomain(uint16 domain, address recipient) internal {\\n        WormState storage wormState = diamondStorage();\\n        wormState.domainToAddress[domain] = recipient;\\n    }\\n\\n    //Below is main send function\\n\\n    function sendFlowTokensMumbai(uint256 tokenNum, uint256 amount) internal {\\n        uint16 targetDomain = 5;\\n        WormState storage wormState = diamondStorage();\\n        address networkDiamond = wormState.domainToAddress[targetDomain];\\n        bytes memory data = ManagerLib.getCurrentFlow();\\n        address token = ManagerLib.convertNumToAddy(tokenNum);\\n        uint256[] memory input = new uint256[](2);\\n        input[0] = tokenNum;\\n        input[1] = amount;\\n        bytes memory dataFlow = ManagerLib.addDataToFront(input, data);\\n\\n        sendCrossChainDeposit(\\n            targetDomain,\\n            networkDiamond,\\n            amount,\\n            token,\\n            dataFlow\\n        );\\n    }\\n\\n    function sendFlowTokensArbG(uint256 tokenNum, uint256 amount) internal {\\n        uint16 targetDomain = 23;\\n        WormState storage wormState = diamondStorage();\\n        address networkDiamond = wormState.domainToAddress[targetDomain];\\n        bytes memory data = ManagerLib.getCurrentFlow();\\n        address token = ManagerLib.convertNumToAddy(tokenNum);\\n        uint256[] memory input = new uint256[](2);\\n        input[0] = tokenNum;\\n        input[1] = amount;\\n        bytes memory dataFlow = ManagerLib.addDataToFront(input, data);\\n        sendCrossChainDeposit(\\n            targetDomain,\\n            networkDiamond,\\n            amount,\\n            token,\\n            dataFlow\\n        );\\n    }\\n\\n    function sendFlowTokenGoerli(uint256 tokenNum, uint256 amount) internal {\\n        uint16 targetDomain = 2;\\n        WormState storage wormState = diamondStorage();\\n        address networkDiamond = wormState.domainToAddress[targetDomain];\\n        bytes memory data = ManagerLib.getCurrentFlow();\\n        address token = ManagerLib.convertNumToAddy(tokenNum);\\n        uint256[] memory input = new uint256[](2);\\n        input[0] = tokenNum;\\n        input[1] = amount;\\n        bytes memory dataFlow = ManagerLib.addDataToFront(input, data);\\n\\n        sendCrossChainDeposit(\\n            targetDomain,\\n            networkDiamond,\\n            amount,\\n            token,\\n            dataFlow\\n        );\\n    }\\n\\n    function sendFlowTokensBase(uint256 tokenNum, uint256 amount) internal {\\n        uint16 targetDomain = 30;\\n        WormState storage wormState = diamondStorage();\\n        address networkDiamond = wormState.domainToAddress[targetDomain];\\n        bytes memory data = ManagerLib.getCurrentFlow();\\n        address token = ManagerLib.convertNumToAddy(tokenNum);\\n        uint256[] memory input = new uint256[](2);\\n        input[0] = tokenNum;\\n        input[1] = amount;\\n        bytes memory dataFlow = ManagerLib.addDataToFront(input, data);\\n        sendCrossChainDeposit(\\n            targetDomain,\\n            networkDiamond,\\n            amount,\\n            token,\\n            dataFlow\\n        );\\n    }\\n\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalVaas,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) internal {\\n        WormState storage wormState = diamondStorage();\\n\\n        TokenReceiver.TokenReceived[]\\n            memory receivedTokens = new TokenReceiver.TokenReceived[](\\n                additionalVaas.length\\n            );\\n\\n        for (uint256 i = 0; i < additionalVaas.length; ++i) {\\n            IWormhole.VM memory parsed = wormState.wormHole.parseVM(\\n                additionalVaas[i]\\n            );\\n            require(\\n                parsed.emitterAddress ==\\n                    wormState.tokenBridge.bridgeContracts(\\n                        parsed.emitterChainId\\n                    ),\\n                \\\"Not a Token Bridge VAA\\\"\\n            );\\n            ITokenBridge.TransferWithPayload memory transfer = wormState\\n                .tokenBridge\\n                .parseTransferWithPayload(parsed.payload);\\n            require(\\n                transfer.to == toWormholeFormat(address(this)) &&\\n                    transfer.toChain == wormState.wormHole.chainId(),\\n                \\\"Token was not sent to this address\\\"\\n            );\\n\\n            wormState.tokenBridge.completeTransferWithPayload(\\n                additionalVaas[i]\\n            );\\n\\n            address thisChainTokenAddress = getTokenAddressOnThisChain(\\n                transfer.tokenChain,\\n                transfer.tokenAddress\\n            );\\n            uint8 decimals = getDecimals(thisChainTokenAddress);\\n            uint256 denormalizedAmount = transfer.amount;\\n            if (decimals > 8)\\n                denormalizedAmount *= uint256(10) ** (decimals - 8);\\n\\n            receivedTokens[i] = TokenReceiver.TokenReceived({\\n                tokenHomeAddress: transfer.tokenAddress,\\n                tokenHomeChain: transfer.tokenChain,\\n                tokenAddress: thisChainTokenAddress,\\n                amount: denormalizedAmount,\\n                amountNormalized: transfer.amount\\n            });\\n        }\\n\\n        // call into overriden method\\n        processRequest(\\n            payload,\\n            receivedTokens,\\n            sourceAddress,\\n            sourceChain,\\n            deliveryHash\\n        );\\n    }\\n\\n    function getDecimals(\\n        address tokenAddress\\n    ) internal view returns (uint8 decimals) {\\n        // query decimals\\n        (, bytes memory queriedDecimals) = address(tokenAddress).staticcall(\\n            abi.encodeWithSignature(\\\"decimals()\\\")\\n        );\\n        decimals = abi.decode(queriedDecimals, (uint8));\\n    }\\n\\n    function getTokenAddressOnThisChain(\\n        uint16 tokenHomeChain,\\n        bytes32 tokenHomeAddress\\n    ) internal view returns (address tokenAddressOnThisChain) {\\n        WormState storage wormState = diamondStorage();\\n\\n        return\\n            tokenHomeChain == wormState.wormHole.chainId()\\n                ? fromWormholeFormat(tokenHomeAddress)\\n                : wormState.tokenBridge.wrappedAsset(\\n                    tokenHomeChain,\\n                    tokenHomeAddress\\n                );\\n    }\\n\\n    function getLastSender() internal view returns (address) {\\n        WormState storage wormState = diamondStorage();\\n        return wormState.lastSender;\\n    }\\n\\n    function getCounter() internal view returns (uint256) {\\n        WormState storage wormState = diamondStorage();\\n        return wormState.counter;\\n    }\\n}\\n\\ncontract WormFacet is IWormholeReceiver {\\n    function getLastSender() external view returns (address) {\\n        return WormLib.getLastSender();\\n    }\\n\\n    function getCounterWorm() external view returns (uint256) {\\n        return WormLib.getCounter();\\n    }\\n\\n    function setTokenBridge(address tokeBridge) external {\\n        WormLib.setTokenBridge(tokeBridge);\\n    }\\n\\n    function setWormHole(address wormHole) external {\\n        WormLib.setWormHole(wormHole);\\n    }\\n\\n    function setWormRelayer(address wormRelay) external {\\n        WormLib.setWormRelayer(wormRelay);\\n    }\\n\\n    function setAddyForDomain(uint16 domain, address recipient) external {\\n        WormLib.setAddyForDomain(domain, recipient);\\n    }\\n\\n    function sendFlowTokensMumbai(uint256[] memory inputs) external {\\n        WormLib.sendFlowTokensMumbai(inputs[0], inputs[1]);\\n    }\\n\\n    function sendFlowTokensArbG(uint256[] memory inputs) external {\\n        WormLib.sendFlowTokensArbG(inputs[0], inputs[1]);\\n    }\\n\\n    function sendFlowTokenGoerli(uint256[] memory inputs) external {\\n        WormLib.sendFlowTokenGoerli(inputs[0], inputs[1]);\\n    }\\n\\n    function sendFlowTokensBase(uint256[] memory inputs) external {\\n        WormLib.sendFlowTokensBase(inputs[0], inputs[1]);\\n    }\\n\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalVaas,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable {\\n        WormLib.receiveWormholeMessages(\\n            payload,\\n            additionalVaas,\\n            sourceAddress,\\n            sourceChain,\\n            deliveryHash\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x491fca64a9baceac3d55533b2cbf58f85db1ef163e416430f364848d8557404f\",\"license\":\"MIT\"},\"contracts/WormHole/Utils.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport \\\"./interfaces/IWormholeRelayer.sol\\\";\\n\\nfunction toWormholeFormat(address addr) pure returns (bytes32) {\\n    return bytes32(uint256(uint160(addr)));\\n}\\n\\nfunction fromWormholeFormat(bytes32 whFormatAddress) pure returns (address) {\\n    if (uint256(whFormatAddress) >> 160 != 0) {\\n        revert NotAnEvmAddress(whFormatAddress);\\n    }\\n    return address(uint160(uint256(whFormatAddress)));\\n}\\n\",\"keccak256\":\"0x6c451da51ccef12d088a6e44181ffbd28b7e665f81d5f71762423547ac454694\",\"license\":\"UNLICENSED\"},\"contracts/WormHole/WormholeRelayerSDK.sol\":{\"content\":\"// SPDX-License-Identifier: UNLICENSED\\npragma solidity ^0.8.13;\\n\\nimport \\\"./interfaces/IWormholeReceiver.sol\\\";\\nimport \\\"./interfaces/IWormholeRelayer.sol\\\";\\nimport \\\"./interfaces/ITokenBridge.sol\\\";\\nimport {IERC20} from \\\"./interfaces/IERC20.sol\\\";\\n\\nimport \\\"./Utils.sol\\\";\\n\\nabstract contract Base {\\n    IWormholeRelayer public immutable wormholeRelayer;\\n    IWormhole public immutable wormhole;\\n\\n    mapping(bytes32 => bool) public seenDeliveryVaaHashes;\\n\\n    address registrationOwner;\\n    mapping(uint16 => bytes32) registeredSenders;\\n\\n    constructor(address _wormholeRelayer, address _wormhole) {\\n        wormholeRelayer = IWormholeRelayer(_wormholeRelayer);\\n        wormhole = IWormhole(_wormhole);\\n        registrationOwner = msg.sender;\\n    }\\n\\n    modifier onlyWormholeRelayer() {\\n        require(\\n            msg.sender == address(wormholeRelayer),\\n            \\\"Msg.sender is not Wormhole Relayer\\\"\\n        );\\n        _;\\n    }\\n\\n    modifier replayProtect(bytes32 deliveryHash) {\\n        require(\\n            !seenDeliveryVaaHashes[deliveryHash],\\n            \\\"Message already processed\\\"\\n        );\\n        seenDeliveryVaaHashes[deliveryHash] = true;\\n        _;\\n    }\\n\\n    modifier isRegisteredSender(uint16 sourceChain, bytes32 sourceAddress) {\\n        require(\\n            registeredSenders[sourceChain] == sourceAddress,\\n            \\\"Not registered sender\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * Sets the registered address for 'sourceChain' to 'sourceAddress'\\n     * So that for messages from 'sourceChain', only ones from 'sourceAddress' are valid\\n     *\\n     * Assumes only one sender per chain is valid\\n     * Sender is the address that called 'send' on the Wormhole Relayer contract on the source chain)\\n     */\\n    function setRegisteredSender(\\n        uint16 sourceChain,\\n        bytes32 sourceAddress\\n    ) public {\\n        require(\\n            msg.sender == registrationOwner,\\n            \\\"Not allowed to set registered sender\\\"\\n        );\\n        registeredSenders[sourceChain] = sourceAddress;\\n    }\\n}\\n\\nabstract contract TokenBase is Base {\\n    ITokenBridge public immutable tokenBridge;\\n\\n    constructor(\\n        address _wormholeRelayer,\\n        address _tokenBridge,\\n        address _wormhole\\n    ) Base(_wormholeRelayer, _wormhole) {\\n        tokenBridge = ITokenBridge(_tokenBridge);\\n    }\\n\\n    function getDecimals(\\n        address tokenAddress\\n    ) internal view returns (uint8 decimals) {\\n        // query decimals\\n        (, bytes memory queriedDecimals) = address(tokenAddress).staticcall(\\n            abi.encodeWithSignature(\\\"decimals()\\\")\\n        );\\n        decimals = abi.decode(queriedDecimals, (uint8));\\n    }\\n\\n    function getTokenAddressOnThisChain(\\n        uint16 tokenHomeChain,\\n        bytes32 tokenHomeAddress\\n    ) internal view returns (address tokenAddressOnThisChain) {\\n        return\\n            tokenHomeChain == wormhole.chainId()\\n                ? fromWormholeFormat(tokenHomeAddress)\\n                : tokenBridge.wrappedAsset(tokenHomeChain, tokenHomeAddress);\\n    }\\n}\\n\\nabstract contract TokenSender is TokenBase {\\n    /**\\n     * transferTokens wraps common boilerplate for sending tokens to another chain using IWormholeRelayer\\n     * - approves tokenBridge to spend 'amount' of 'token'\\n     * - emits token transfer VAA\\n     * - returns VAA key for inclusion in WormholeRelayer `additionalVaas` argument\\n     *\\n     * Note: this function uses transferTokensWithPayload instead of transferTokens since the former requires that only the targetAddress\\n     *       can redeem transfers. Otherwise it's possible for another address to redeem the transfer before the targetContract is invoked by\\n     *       the offchain relayer and the target contract would have to be hardened against this.\\n     *\\n     */\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress\\n    ) internal returns (VaaKey memory) {\\n        return\\n            transferTokens(\\n                token,\\n                amount,\\n                targetChain,\\n                targetAddress,\\n                bytes(\\\"\\\")\\n            );\\n    }\\n\\n    /**\\n     * transferTokens wraps common boilerplate for sending tokens to another chain using IWormholeRelayer.\\n     * A payload can be included in the transfer vaa. By including a payload here instead of the deliveryVaa,\\n     * fewer trust assumptions are placed on the WormholeRelayer contract.\\n     *\\n     * - approves tokenBridge to spend 'amount' of 'token'\\n     * - emits token transfer VAA\\n     * - returns VAA key for inclusion in WormholeRelayer `additionalVaas` argument\\n     *\\n     * Note: this function uses transferTokensWithPayload instead of transferTokens since the former requires that only the targetAddress\\n     *       can redeem transfers. Otherwise it's possible for another address to redeem the transfer before the targetContract is invoked by\\n     *       the offchain relayer and the target contract would have to be hardened against this.\\n     */\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload\\n    ) internal returns (VaaKey memory) {\\n        IERC20(token).approve(address(tokenBridge), amount);\\n        uint64 sequence = tokenBridge.transferTokensWithPayload{\\n            value: wormhole.messageFee()\\n        }(\\n            token,\\n            amount,\\n            targetChain,\\n            toWormholeFormat(targetAddress),\\n            0,\\n            payload\\n        );\\n        return\\n            VaaKey({\\n                emitterAddress: toWormholeFormat(address(tokenBridge)),\\n                chainId: wormhole.chainId(),\\n                sequence: sequence\\n            });\\n    }\\n\\n    function sendTokenWithPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address token,\\n        uint256 amount,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) internal returns (uint64) {\\n        VaaKey[] memory vaaKeys = new VaaKey[](1);\\n        vaaKeys[0] = transferTokens(token, amount, targetChain, targetAddress);\\n\\n        (uint256 cost, ) = wormholeRelayer.quoteEVMDeliveryPrice(\\n            targetChain,\\n            receiverValue,\\n            gasLimit\\n        );\\n        return\\n            wormholeRelayer.sendVaasToEvm{value: cost}(\\n                targetChain,\\n                targetAddress,\\n                payload,\\n                receiverValue,\\n                gasLimit,\\n                vaaKeys,\\n                refundChain,\\n                refundAddress\\n            );\\n    }\\n}\\n\\nabstract contract TokenReceiver is TokenBase {\\n    struct TokenReceived {\\n        bytes32 tokenHomeAddress;\\n        uint16 tokenHomeChain;\\n        address tokenAddress; // wrapped address if tokenHomeChain !== this chain, else tokenHomeAddress (in evm address format)\\n        uint256 amount;\\n        uint256 amountNormalized; // if decimals > 8, normalized to 8 decimal places\\n    }\\n\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalVaas,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable {\\n        TokenReceived[] memory receivedTokens = new TokenReceived[](\\n            additionalVaas.length\\n        );\\n\\n        for (uint256 i = 0; i < additionalVaas.length; ++i) {\\n            IWormhole.VM memory parsed = wormhole.parseVM(additionalVaas[i]);\\n            require(\\n                parsed.emitterAddress ==\\n                    tokenBridge.bridgeContracts(parsed.emitterChainId),\\n                \\\"Not a Token Bridge VAA\\\"\\n            );\\n            ITokenBridge.TransferWithPayload memory transfer = tokenBridge\\n                .parseTransferWithPayload(parsed.payload);\\n            require(\\n                transfer.to == toWormholeFormat(address(this)) &&\\n                    transfer.toChain == wormhole.chainId(),\\n                \\\"Token was not sent to this address\\\"\\n            );\\n\\n            tokenBridge.completeTransferWithPayload(additionalVaas[i]);\\n\\n            address thisChainTokenAddress = getTokenAddressOnThisChain(\\n                transfer.tokenChain,\\n                transfer.tokenAddress\\n            );\\n            uint8 decimals = getDecimals(thisChainTokenAddress);\\n            uint256 denormalizedAmount = transfer.amount;\\n            if (decimals > 8)\\n                denormalizedAmount *= uint256(10) ** (decimals - 8);\\n\\n            receivedTokens[i] = TokenReceived({\\n                tokenHomeAddress: transfer.tokenAddress,\\n                tokenHomeChain: transfer.tokenChain,\\n                tokenAddress: thisChainTokenAddress,\\n                amount: denormalizedAmount,\\n                amountNormalized: transfer.amount\\n            });\\n        }\\n\\n        // call into overriden method\\n        receivePayloadAndTokens(\\n            payload,\\n            receivedTokens,\\n            sourceAddress,\\n            sourceChain,\\n            deliveryHash\\n        );\\n    }\\n\\n    function receivePayloadAndTokens(\\n        bytes memory payload,\\n        TokenReceived[] memory receivedTokens,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) internal virtual {}\\n}\\n\",\"keccak256\":\"0xddfef9cbded9dfd4b3350f89a4110a07e829d31c5598272670b6142604bbaad2\",\"license\":\"UNLICENSED\"},\"contracts/WormHole/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(\\n        address indexed owner,\\n        address indexed spender,\\n        uint256 value\\n    );\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(\\n        address owner,\\n        address spender\\n    ) external view returns (uint256);\\n\\n    function mint(uint256 owner) external returns (bool);\\n\\n    function allocateTo(address ownerAddress, uint256 value) external;\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    function drip(address token) external;\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n}\\n\",\"keccak256\":\"0x674bbd8a04a74446b1b5423b75d5c5f1725b4dd45c5da1cd384620a65cc18455\",\"license\":\"MIT\"},\"contracts/WormHole/interfaces/ITokenBridge.sol\":{\"content\":\"// contracts/Bridge.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IWETH.sol\\\";\\nimport \\\"./IWormhole.sol\\\";\\n\\ninterface ITokenBridge {\\n    struct Transfer {\\n        uint8 payloadID;\\n        uint256 amount;\\n        bytes32 tokenAddress;\\n        uint16 tokenChain;\\n        bytes32 to;\\n        uint16 toChain;\\n        uint256 fee;\\n    }\\n\\n    struct TransferWithPayload {\\n        uint8 payloadID;\\n        uint256 amount;\\n        bytes32 tokenAddress;\\n        uint16 tokenChain;\\n        bytes32 to;\\n        uint16 toChain;\\n        bytes32 fromAddress;\\n        bytes payload;\\n    }\\n\\n    struct AssetMeta {\\n        uint8 payloadID;\\n        bytes32 tokenAddress;\\n        uint16 tokenChain;\\n        uint8 decimals;\\n        bytes32 symbol;\\n        bytes32 name;\\n    }\\n\\n    struct RegisterChain {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chainId;\\n        uint16 emitterChainID;\\n        bytes32 emitterAddress;\\n    }\\n\\n    struct UpgradeContract {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chainId;\\n        bytes32 newContract;\\n    }\\n\\n    struct RecoverChainId {\\n        bytes32 module;\\n        uint8 action;\\n        uint256 evmChainId;\\n        uint16 newChainId;\\n    }\\n\\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\\n\\n    function _parseTransferCommon(bytes memory encoded) external pure returns (Transfer memory transfer);\\n\\n    function attestToken(address tokenAddress, uint32 nonce) external payable returns (uint64 sequence);\\n\\n    function wrapAndTransferETH(uint16 recipientChain, bytes32 recipient, uint256 arbiterFee, uint32 nonce)\\n        external\\n        payable\\n        returns (uint64 sequence);\\n\\n    function wrapAndTransferETHWithPayload(uint16 recipientChain, bytes32 recipient, uint32 nonce, bytes memory payload)\\n        external\\n        payable\\n        returns (uint64 sequence);\\n\\n    function transferTokens(\\n        address token,\\n        uint256 amount,\\n        uint16 recipientChain,\\n        bytes32 recipient,\\n        uint256 arbiterFee,\\n        uint32 nonce\\n    ) external payable returns (uint64 sequence);\\n\\n    function transferTokensWithPayload(\\n        address token,\\n        uint256 amount,\\n        uint16 recipientChain,\\n        bytes32 recipient,\\n        uint32 nonce,\\n        bytes memory payload\\n    ) external payable returns (uint64 sequence);\\n\\n    function updateWrapped(bytes memory encodedVm) external returns (address token);\\n\\n    function createWrapped(bytes memory encodedVm) external returns (address token);\\n\\n    function completeTransferWithPayload(bytes memory encodedVm) external returns (bytes memory);\\n\\n    function completeTransferAndUnwrapETHWithPayload(bytes memory encodedVm) external returns (bytes memory);\\n\\n    function completeTransfer(bytes memory encodedVm) external;\\n\\n    function completeTransferAndUnwrapETH(bytes memory encodedVm) external;\\n\\n    function encodeAssetMeta(AssetMeta memory meta) external pure returns (bytes memory encoded);\\n\\n    function encodeTransfer(Transfer memory transfer) external pure returns (bytes memory encoded);\\n\\n    function encodeTransferWithPayload(TransferWithPayload memory transfer)\\n        external\\n        pure\\n        returns (bytes memory encoded);\\n\\n    function parsePayloadID(bytes memory encoded) external pure returns (uint8 payloadID);\\n\\n    function parseAssetMeta(bytes memory encoded) external pure returns (AssetMeta memory meta);\\n\\n    function parseTransfer(bytes memory encoded) external pure returns (Transfer memory transfer);\\n\\n    function parseTransferWithPayload(bytes memory encoded)\\n        external\\n        pure\\n        returns (TransferWithPayload memory transfer);\\n\\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\\n\\n    function isInitialized(address impl) external view returns (bool);\\n\\n    function isTransferCompleted(bytes32 hash) external view returns (bool);\\n\\n    function wormhole() external view returns (IWormhole);\\n\\n    function chainId() external view returns (uint16);\\n\\n    function evmChainId() external view returns (uint256);\\n\\n    function isFork() external view returns (bool);\\n\\n    function governanceChainId() external view returns (uint16);\\n\\n    function governanceContract() external view returns (bytes32);\\n\\n    function wrappedAsset(uint16 tokenChainId, bytes32 tokenAddress) external view returns (address);\\n\\n    function bridgeContracts(uint16 chainId_) external view returns (bytes32);\\n\\n    function tokenImplementation() external view returns (address);\\n\\n    function WETH() external view returns (IWETH);\\n\\n    function outstandingBridged(address token) external view returns (uint256);\\n\\n    function isWrappedAsset(address token) external view returns (bool);\\n\\n    function finality() external view returns (uint8);\\n\\n    function implementation() external view returns (address);\\n\\n    function initialize() external;\\n\\n    function registerChain(bytes memory encodedVM) external;\\n\\n    function upgrade(bytes memory encodedVM) external;\\n\\n    function submitRecoverChainId(bytes memory encodedVM) external;\\n\\n    function parseRegisterChain(bytes memory encoded) external pure returns (RegisterChain memory chain);\\n\\n    function parseUpgrade(bytes memory encoded) external pure returns (UpgradeContract memory chain);\\n\\n    function parseRecoverChainId(bytes memory encodedRecoverChainId)\\n        external\\n        pure\\n        returns (RecoverChainId memory rci);\\n}\\n\",\"keccak256\":\"0x808b67552c15f95ca2da6381179762b7cb95295a7ecafd2c5ee693c04488d4bf\",\"license\":\"Apache 2\"},\"contracts/WormHole/interfaces/IWETH.sol\":{\"content\":\"// contracts/Bridge.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\ninterface IWETH is IERC20 {\\n    function deposit() external payable;\\n    function withdraw(uint256 amount) external;\\n}\\n\",\"keccak256\":\"0x1db59bb7a24fe6b6949a29b7ee9bf4495eaec9984c730666e3ae0f2ca8aacb4d\",\"license\":\"Apache 2\"},\"contracts/WormHole/interfaces/IWormhole.sol\":{\"content\":\"// contracts/Messages.sol\\n// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\ninterface IWormhole {\\n    struct GuardianSet {\\n        address[] keys;\\n        uint32 expirationTime;\\n    }\\n\\n    struct Signature {\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        uint8 guardianIndex;\\n    }\\n\\n    struct VM {\\n        uint8 version;\\n        uint32 timestamp;\\n        uint32 nonce;\\n        uint16 emitterChainId;\\n        bytes32 emitterAddress;\\n        uint64 sequence;\\n        uint8 consistencyLevel;\\n        bytes payload;\\n        uint32 guardianSetIndex;\\n        Signature[] signatures;\\n        bytes32 hash;\\n    }\\n\\n    struct ContractUpgrade {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n        address newContract;\\n    }\\n\\n    struct GuardianSetUpgrade {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n        GuardianSet newGuardianSet;\\n        uint32 newGuardianSetIndex;\\n    }\\n\\n    struct SetMessageFee {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n        uint256 messageFee;\\n    }\\n\\n    struct TransferFees {\\n        bytes32 module;\\n        uint8 action;\\n        uint16 chain;\\n        uint256 amount;\\n        bytes32 recipient;\\n    }\\n\\n    struct RecoverChainId {\\n        bytes32 module;\\n        uint8 action;\\n        uint256 evmChainId;\\n        uint16 newChainId;\\n    }\\n\\n    event LogMessagePublished(\\n        address indexed sender, uint64 sequence, uint32 nonce, bytes payload, uint8 consistencyLevel\\n    );\\n    event ContractUpgraded(address indexed oldContract, address indexed newContract);\\n    event GuardianSetAdded(uint32 indexed index);\\n\\n    function publishMessage(uint32 nonce, bytes memory payload, uint8 consistencyLevel)\\n        external\\n        payable\\n        returns (uint64 sequence);\\n\\n    function initialize() external;\\n\\n    function parseAndVerifyVM(bytes calldata encodedVM)\\n        external\\n        view\\n        returns (VM memory vm, bool valid, string memory reason);\\n\\n    function verifyVM(VM memory vm) external view returns (bool valid, string memory reason);\\n\\n    function verifySignatures(bytes32 hash, Signature[] memory signatures, GuardianSet memory guardianSet)\\n        external\\n        pure\\n        returns (bool valid, string memory reason);\\n\\n    function parseVM(bytes memory encodedVM) external pure returns (VM memory vm);\\n\\n    function quorum(uint256 numGuardians) external pure returns (uint256 numSignaturesRequiredForQuorum);\\n\\n    function getGuardianSet(uint32 index) external view returns (GuardianSet memory);\\n\\n    function getCurrentGuardianSetIndex() external view returns (uint32);\\n\\n    function getGuardianSetExpiry() external view returns (uint32);\\n\\n    function governanceActionIsConsumed(bytes32 hash) external view returns (bool);\\n\\n    function isInitialized(address impl) external view returns (bool);\\n\\n    function chainId() external view returns (uint16);\\n\\n    function isFork() external view returns (bool);\\n\\n    function governanceChainId() external view returns (uint16);\\n\\n    function governanceContract() external view returns (bytes32);\\n\\n    function messageFee() external view returns (uint256);\\n\\n    function evmChainId() external view returns (uint256);\\n\\n    function nextSequence(address emitter) external view returns (uint64);\\n\\n    function parseContractUpgrade(bytes memory encodedUpgrade) external pure returns (ContractUpgrade memory cu);\\n\\n    function parseGuardianSetUpgrade(bytes memory encodedUpgrade)\\n        external\\n        pure\\n        returns (GuardianSetUpgrade memory gsu);\\n\\n    function parseSetMessageFee(bytes memory encodedSetMessageFee) external pure returns (SetMessageFee memory smf);\\n\\n    function parseTransferFees(bytes memory encodedTransferFees) external pure returns (TransferFees memory tf);\\n\\n    function parseRecoverChainId(bytes memory encodedRecoverChainId)\\n        external\\n        pure\\n        returns (RecoverChainId memory rci);\\n\\n    function submitContractUpgrade(bytes memory _vm) external;\\n\\n    function submitSetMessageFee(bytes memory _vm) external;\\n\\n    function submitNewGuardianSet(bytes memory _vm) external;\\n\\n    function submitTransferFees(bytes memory _vm) external;\\n\\n    function submitRecoverChainId(bytes memory _vm) external;\\n}\\n\",\"keccak256\":\"0x726133901a485eb12ac5792ec7457e038c7faa90ded11539a3918d1928cb1f8c\",\"license\":\"Apache 2\"},\"contracts/WormHole/interfaces/IWormholeReceiver.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for a contract which can receive Wormhole messages.\\n */\\ninterface IWormholeReceiver {\\n    /**\\n     * @notice When a `send` is performed with this contract as the target, this function will be\\n     *     invoked by the WormholeRelayer contract\\n     *\\n     * NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it.\\n     *\\n     * We also recommend that this function:\\n     *   - Stores all received `deliveryHash`s in a mapping `(bytes32 => bool)`, and\\n     *       on every call, checks that deliveryHash has not already been stored in the\\n     *       map (This is to prevent other users maliciously trying to relay the same message)\\n     *   - Checks that `sourceChain` and `sourceAddress` are indeed who\\n     *       you expect to have requested the calling of `send` on the source chain\\n     *\\n     * The invocation of this function corresponding to the `send` request will have msg.value equal\\n     *   to the receiverValue specified in the send request.\\n     *\\n     * If the invocation of this function reverts or exceeds the gas limit\\n     *   specified by the send requester, this delivery will result in a `ReceiverFailure`.\\n     *\\n     * @param payload - an arbitrary message which was included in the delivery by the\\n     *     requester.\\n     * @param additionalVaas - Additional VAAs which were requested to be included in this delivery.\\n     *   They are guaranteed to all be included and in the same order as was specified in the\\n     *     delivery request.\\n     * @param sourceAddress - the (wormhole format) address on the sending chain which requested\\n     *     this delivery.\\n     * @param sourceChain - the wormhole chain ID where this delivery was requested.\\n     * @param deliveryHash - the VAA hash of the deliveryVAA.\\n     *\\n     * NOTE: These signedVaas are NOT verified by the Wormhole core contract prior to being provided\\n     *     to this call. Always make sure `parseAndVerify()` is called on the Wormhole core contract\\n     *     before trusting the content of a raw VAA, otherwise the VAA may be invalid or malicious.\\n     */\\n    function receiveWormholeMessages(\\n        bytes memory payload,\\n        bytes[] memory additionalVaas,\\n        bytes32 sourceAddress,\\n        uint16 sourceChain,\\n        bytes32 deliveryHash\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x795d0ddb313e097be7a16d7ff0cce2b50f93955a05cdc68bf6cf7df8ee23cfc1\",\"license\":\"Apache 2\"},\"contracts/WormHole/interfaces/IWormholeRelayer.sol\":{\"content\":\"// SPDX-License-Identifier: Apache 2\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title WormholeRelayer\\n * @author\\n * @notice This project allows developers to build cross-chain applications powered by Wormhole without needing to\\n * write and run their own relaying infrastructure\\n *\\n * We implement the IWormholeRelayer interface that allows users to request a delivery provider to relay a payload (and/or additional VAAs)\\n * to a chain and address of their choice.\\n */\\n\\n/**\\n * @notice VaaKey identifies a wormhole message\\n *\\n * @custom:member chainId Wormhole chain ID of the chain where this VAA was emitted from\\n * @custom:member emitterAddress Address of the emitter of the VAA, in Wormhole bytes32 format\\n * @custom:member sequence Sequence number of the VAA\\n */\\nstruct VaaKey {\\n    uint16 chainId;\\n    bytes32 emitterAddress;\\n    uint64 sequence;\\n}\\n\\ninterface IWormholeRelayerBase {\\n    event SendEvent(uint64 indexed sequence, uint256 deliveryQuote, uint256 paymentForExtraReceiverValue);\\n\\n    function getRegisteredWormholeRelayerContract(uint16 chainId) external view returns (bytes32);\\n}\\n\\n/**\\n * @title IWormholeRelayerSend\\n * @notice The interface to request deliveries\\n */\\ninterface IWormholeRelayerSend is IWormholeRelayerBase {\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendPayloadToEvm` function\\n     * with `refundChain` and `refundAddress` as parameters\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendPayloadToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * Any refunds (from leftover gas) will be paid to the delivery provider. In order to receive the refunds, use the `sendVaasToEvm` function\\n     * with `refundChain` and `refundAddress` as parameters\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        VaaKey[] memory vaaKeys\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the default delivery provider\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to `receiverValue`\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to `quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit)`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendVaasToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        VaaKey[] memory vaaKeys,\\n        uint16 refundChain,\\n        address refundAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with gas limit `gasLimit` and `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteEVMDeliveryPrice(targetChain, receiverValue, gasLimit, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver)\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param gasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function sendToEvm(\\n        uint16 targetChain,\\n        address targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        uint256 gasLimit,\\n        uint16 refundChain,\\n        address refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Publishes an instruction for the delivery provider at `deliveryProviderAddress`\\n     * to relay a payload and VAAs specified by `vaaKeys` to the address `targetAddress` on chain `targetChain`\\n     * with `msg.value` equal to\\n     * receiverValue + (arbitrary amount that is paid for by paymentForExtraReceiverValue of this chain's wei) in targetChain wei.\\n     *\\n     * Any refunds (from leftover gas) will be sent to `refundAddress` on chain `refundChain`\\n     * `targetAddress` must implement the IWormholeReceiver interface\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteDeliveryPrice(targetChain, receiverValue, encodedExecutionParameters, deliveryProviderAddress) + paymentForExtraReceiverValue\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param targetAddress address to call on targetChain (that implements IWormholeReceiver), in Wormhole bytes32 format\\n     * @param payload arbitrary bytes to pass in as parameter in call to `targetAddress`\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param paymentForExtraReceiverValue amount (in current chain currency units) to spend on extra receiverValue\\n     *        (in addition to the `receiverValue` specified)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param refundChain The chain to deliver any refund to, in Wormhole Chain ID format\\n     * @param refundAddress The address on `refundChain` to deliver any refund to, in Wormhole bytes32 format\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @param vaaKeys Additional VAAs to pass in as parameter in call to `targetAddress`\\n     * @param consistencyLevel Consistency level with which to publish the delivery instructions - see\\n     *        https://book.wormhole.com/wormhole/3_coreLayerContracts.html?highlight=consistency#consistency-levels\\n     * @return sequence sequence number of published VAA containing delivery instructions\\n     */\\n    function send(\\n        uint16 targetChain,\\n        bytes32 targetAddress,\\n        bytes memory payload,\\n        uint256 receiverValue,\\n        uint256 paymentForExtraReceiverValue,\\n        bytes memory encodedExecutionParameters,\\n        uint16 refundChain,\\n        bytes32 refundAddress,\\n        address deliveryProviderAddress,\\n        VaaKey[] memory vaaKeys,\\n        uint8 consistencyLevel\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered\\n     * (e.g. with a different delivery provider)\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteEVMDeliveryPrice(targetChain, newReceiverValue, newGasLimit, newDeliveryProviderAddress)\\n     *\\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     *\\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newGasLimit gas limit with which to call `targetAddress`. Any units of gas unused will be refunded according to the\\n     *        `targetChainRefundPerGasUnused` rate quoted by the delivery provider, to the refund chain and address specified in the original request\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     *\\n     * @notice *** This will only be able to succeed if the following is true **\\n     *         - newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     */\\n    function resendToEvm(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        uint256 newReceiverValue,\\n        uint256 newGasLimit,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Requests a previously published delivery instruction to be redelivered\\n     *\\n     *\\n     * This function must be called with `msg.value` equal to\\n     * quoteDeliveryPrice(targetChain, newReceiverValue, newEncodedExecutionParameters, newDeliveryProviderAddress)\\n     *\\n     * @param deliveryVaaKey VaaKey identifying the wormhole message containing the\\n     *        previously published delivery instructions\\n     * @param targetChain The target chain that the original delivery targeted. Must match targetChain from original delivery instructions\\n     * @param newReceiverValue new msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param newEncodedExecutionParameters new encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param newDeliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return sequence sequence number of published VAA containing redelivery instructions\\n     *\\n     *  @notice *** This will only be able to succeed if the following is true **\\n     *         - (For EVM_V1) newGasLimit >= gas limit of the old instruction\\n     *         - newReceiverValue >= receiver value of the old instruction\\n     *         - (For EVM_V1) newDeliveryProvider's `targetChainRefundPerGasUnused` >= old relay provider's `targetChainRefundPerGasUnused`\\n     */\\n    function resend(\\n        VaaKey memory deliveryVaaKey,\\n        uint16 targetChain,\\n        uint256 newReceiverValue,\\n        bytes memory newEncodedExecutionParameters,\\n        address newDeliveryProviderAddress\\n    ) external payable returns (uint64 sequence);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using the default delivery provider\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\n     *         if a refundAddress is specified\\n     */\\n    function quoteEVMDeliveryPrice(uint16 targetChain, uint256 receiverValue, uint256 gasLimit)\\n        external\\n        view\\n        returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param gasLimit gas limit with which to call `targetAddress`.\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return targetChainRefundPerGasUnused amount of target chain currency that will be refunded per unit of gas unused,\\n     *         if a refundAddress is specified\\n     */\\n    function quoteEVMDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        uint256 gasLimit,\\n        address deliveryProviderAddress\\n    ) external view returns (uint256 nativePriceQuote, uint256 targetChainRefundPerGasUnused);\\n\\n    /**\\n     * @notice Returns the price to request a relay to chain `targetChain`, using delivery provider `deliveryProviderAddress`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param receiverValue msg.value that delivery provider should pass in for call to `targetAddress` (in targetChain currency units)\\n     * @param encodedExecutionParameters encoded information on how to execute delivery that may impact pricing\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` with which to call `targetAddress`\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return nativePriceQuote Price, in units of current chain currency, that the delivery provider charges to perform the relay\\n     * @return encodedExecutionInfo encoded information on how the delivery will be executed\\n     *        e.g. for version EVM_V1, this is a struct that encodes the `gasLimit` and `targetChainRefundPerGasUnused`\\n     *             (which is the amount of target chain currency that will be refunded per unit of gas unused,\\n     *              if a refundAddress is specified)\\n     */\\n    function quoteDeliveryPrice(\\n        uint16 targetChain,\\n        uint256 receiverValue,\\n        bytes memory encodedExecutionParameters,\\n        address deliveryProviderAddress\\n    ) external view returns (uint256 nativePriceQuote, bytes memory encodedExecutionInfo);\\n\\n    /**\\n     * @notice Returns the (extra) amount of target chain currency that `targetAddress`\\n     * will be called with, if the `paymentForExtraReceiverValue` field is set to `currentChainAmount`\\n     *\\n     * @param targetChain in Wormhole Chain ID format\\n     * @param currentChainAmount The value that `paymentForExtraReceiverValue` will be set to\\n     * @param deliveryProviderAddress The address of the desired delivery provider's implementation of IDeliveryProvider\\n     * @return targetChainAmount The amount such that if `targetAddress` will be called with `msg.value` equal to\\n     *         receiverValue + targetChainAmount\\n     */\\n    function quoteNativeForChain(uint16 targetChain, uint256 currentChainAmount, address deliveryProviderAddress)\\n        external\\n        view\\n        returns (uint256 targetChainAmount);\\n\\n    /**\\n     * @notice Returns the address of the current default delivery provider\\n     * @return deliveryProvider The address of (the default delivery provider)'s contract on this source\\n     *   chain. This must be a contract that implements IDeliveryProvider.\\n     */\\n    function getDefaultDeliveryProvider() external view returns (address deliveryProvider);\\n}\\n\\n/**\\n * @title IWormholeRelayerDelivery\\n * @notice The interface to execute deliveries. Only relevant for Delivery Providers\\n */\\ninterface IWormholeRelayerDelivery is IWormholeRelayerBase {\\n    enum DeliveryStatus {\\n        SUCCESS,\\n        RECEIVER_FAILURE\\n    }\\n\\n    enum RefundStatus {\\n        REFUND_SENT,\\n        REFUND_FAIL,\\n        CROSS_CHAIN_REFUND_SENT,\\n        CROSS_CHAIN_REFUND_FAIL_PROVIDER_NOT_SUPPORTED,\\n        CROSS_CHAIN_REFUND_FAIL_NOT_ENOUGH\\n    }\\n\\n    /**\\n     * @custom:member recipientContract - The target contract address\\n     * @custom:member sourceChain - The chain which this delivery was requested from (in wormhole\\n     *     ChainID format)\\n     * @custom:member sequence - The wormhole sequence number of the delivery VAA on the source chain\\n     *     corresponding to this delivery request\\n     * @custom:member deliveryVaaHash - The hash of the delivery VAA corresponding to this delivery\\n     *     request\\n     * @custom:member gasUsed - The amount of gas that was used to call your target contract\\n     * @custom:member status:\\n     *   - RECEIVER_FAILURE, if the target contract reverts\\n     *   - SUCCESS, if the target contract doesn't revert \\n     * @custom:member additionalStatusInfo:\\n     *   - If status is SUCCESS, then this is empty.\\n     *   - If status is RECEIVER_FAILURE, this is `RETURNDATA_TRUNCATION_THRESHOLD` bytes of the\\n     *       return data (i.e. potentially truncated revert reason information).\\n     * @custom:member refundStatus - Result of the refund. REFUND_SUCCESS or REFUND_FAIL are for\\n     *     refunds where targetChain=refundChain; the others are for targetChain!=refundChain,\\n     *     where a cross chain refund is necessary\\n     * @custom:member overridesInfo:\\n     *   - If not an override: empty bytes array\\n     *   - Otherwise: An encoded `DeliveryOverride`\\n     */\\n    event Delivery(\\n        address indexed recipientContract,\\n        uint16 indexed sourceChain,\\n        uint64 indexed sequence,\\n        bytes32 deliveryVaaHash,\\n        DeliveryStatus status,\\n        uint256 gasUsed,\\n        RefundStatus refundStatus,\\n        bytes additionalStatusInfo,\\n        bytes overridesInfo\\n    );\\n\\n    /**\\n     * @notice The delivery provider calls `deliver` to relay messages as described by one delivery instruction\\n     *\\n     * The delivery provider must pass in the specified (by VaaKeys[]) signed wormhole messages (VAAs) from the source chain\\n     * as well as the signed wormhole message with the delivery instructions (the delivery VAA)\\n     *\\n     * The messages will be relayed to the target address (with the specified gas limit and receiver value) iff the following checks are met:\\n     * - the delivery VAA has a valid signature\\n     * - the delivery VAA's emitter is one of these WormholeRelayer contracts\\n     * - the delivery provider passed in at least enough of this chain's currency as msg.value (enough meaning the maximum possible refund)\\n     * - the instruction's target chain is this chain\\n     * - the relayed signed VAAs match the descriptions in container.messages (the VAA hashes match, or the emitter address, sequence number pair matches, depending on the description given)\\n     *\\n     * @param encodedVMs - An array of signed wormhole messages (all from the same source chain\\n     *     transaction)\\n     * @param encodedDeliveryVAA - Signed wormhole message from the source chain's WormholeRelayer\\n     *     contract with payload being the encoded delivery instruction container\\n     * @param relayerRefundAddress - The address to which any refunds to the delivery provider\\n     *     should be sent\\n     * @param deliveryOverrides - Optional overrides field which must be either an empty bytes array or\\n     *     an encoded DeliveryOverride struct\\n     */\\n    function deliver(\\n        bytes[] memory encodedVMs,\\n        bytes memory encodedDeliveryVAA,\\n        address payable relayerRefundAddress,\\n        bytes memory deliveryOverrides\\n    ) external payable;\\n}\\n\\ninterface IWormholeRelayer is IWormholeRelayerDelivery, IWormholeRelayerSend {}\\n\\n/*\\n *  Errors thrown by IWormholeRelayer contract\\n */\\n\\n// Bound chosen by the following formula: `memoryWord * 4 + selectorSize`.\\n// This means that an error identifier plus four fixed size arguments should be available to developers.\\n// In the case of a `require` revert with error message, this should provide 2 memory word's worth of data.\\nuint256 constant RETURNDATA_TRUNCATION_THRESHOLD = 132;\\n\\n//When msg.value was not equal to `delivery provider's quoted delivery price` + `paymentForExtraReceiverValue`\\nerror InvalidMsgValue(uint256 msgValue, uint256 totalFee);\\n\\nerror RequestedGasLimitTooLow();\\n\\nerror DeliveryProviderDoesNotSupportTargetChain(address relayer, uint16 chainId);\\nerror DeliveryProviderCannotReceivePayment();\\n\\n//When calling `delivery()` a second time even though a delivery is already in progress\\nerror ReentrantDelivery(address msgSender, address lockedBy);\\n\\nerror InvalidPayloadId(uint8 parsed, uint8 expected);\\nerror InvalidPayloadLength(uint256 received, uint256 expected);\\nerror InvalidVaaKeyType(uint8 parsed);\\n\\nerror InvalidDeliveryVaa(string reason);\\n//When the delivery VAA (signed wormhole message with delivery instructions) was not emitted by the\\n//  registered WormholeRelayer contract\\nerror InvalidEmitter(bytes32 emitter, bytes32 registered, uint16 chainId);\\nerror VaaKeysLengthDoesNotMatchVaasLength(uint256 keys, uint256 vaas);\\nerror VaaKeysDoNotMatchVaas(uint8 index);\\n//When someone tries to call an external function of the WormholeRelayer that is only intended to be\\n//  called by the WormholeRelayer itself (to allow retroactive reverts for atomicity)\\nerror RequesterNotWormholeRelayer();\\n\\n//When trying to relay a `DeliveryInstruction` to any other chain but the one it was specified for\\nerror TargetChainIsNotThisChain(uint16 targetChain);\\n//When a `DeliveryOverride` contains a gas limit that's less than the original\\nerror InvalidOverrideGasLimit();\\n//When a `DeliveryOverride` contains a receiver value that's less than the original\\nerror InvalidOverrideReceiverValue();\\n//When a `DeliveryOverride` contains a 'refund per unit of gas unused' that's less than the original\\nerror InvalidOverrideRefundPerGasUnused();\\n\\n//When the delivery provider doesn't pass in sufficient funds (i.e. msg.value does not cover the\\n// maximum possible refund to the user)\\nerror InsufficientRelayerFunds(uint256 msgValue, uint256 minimum);\\n\\n//When a bytes32 field can't be converted into a 20 byte EVM address, because the 12 padding bytes\\n//  are non-zero (duplicated from Utils.sol)\\nerror NotAnEvmAddress(bytes32);\\n\",\"keccak256\":\"0x1517fe326d98cf485334ae07709fe7065b517a09305891d7961a53c5d30fb089\",\"license\":\"Apache 2\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.4.22 <0.9.0;\\n\\nlibrary console {\\n    address constant CONSOLE_ADDRESS =\\n        0x000000000000000000636F6e736F6c652e6c6f67;\\n\\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\\n        address consoleAddress = CONSOLE_ADDRESS;\\n        /// @solidity memory-safe-assembly\\n        assembly {\\n            pop(\\n                staticcall(\\n                    gas(),\\n                    consoleAddress,\\n                    add(payload, 32),\\n                    mload(payload),\\n                    0,\\n                    0\\n                )\\n            )\\n        }\\n    }\\n\\n    function _castToPure(\\n      function(bytes memory) internal view fnIn\\n    ) internal pure returns (function(bytes memory) pure fnOut) {\\n        assembly {\\n            fnOut := fnIn\\n        }\\n    }\\n\\n    function _sendLogPayload(bytes memory payload) internal pure {\\n        _castToPure(_sendLogPayloadImplementation)(payload);\\n    }\\n\\n    function log() internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n    }\\n    function logInt(int256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(int256)\\\", p0));\\n    }\\n\\n    function logUint(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function logString(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function logBool(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function logAddress(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function logBytes(bytes memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n    }\\n\\n    function logBytes1(bytes1 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n    }\\n\\n    function logBytes2(bytes2 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n    }\\n\\n    function logBytes3(bytes3 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n    }\\n\\n    function logBytes4(bytes4 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n    }\\n\\n    function logBytes5(bytes5 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n    }\\n\\n    function logBytes6(bytes6 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n    }\\n\\n    function logBytes7(bytes7 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n    }\\n\\n    function logBytes8(bytes8 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n    }\\n\\n    function logBytes9(bytes9 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n    }\\n\\n    function logBytes10(bytes10 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n    }\\n\\n    function logBytes11(bytes11 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n    }\\n\\n    function logBytes12(bytes12 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n    }\\n\\n    function logBytes13(bytes13 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n    }\\n\\n    function logBytes14(bytes14 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n    }\\n\\n    function logBytes15(bytes15 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n    }\\n\\n    function logBytes16(bytes16 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n    }\\n\\n    function logBytes17(bytes17 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n    }\\n\\n    function logBytes18(bytes18 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n    }\\n\\n    function logBytes19(bytes19 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n    }\\n\\n    function logBytes20(bytes20 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n    }\\n\\n    function logBytes21(bytes21 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n    }\\n\\n    function logBytes22(bytes22 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n    }\\n\\n    function logBytes23(bytes23 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n    }\\n\\n    function logBytes24(bytes24 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n    }\\n\\n    function logBytes25(bytes25 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n    }\\n\\n    function logBytes26(bytes26 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n    }\\n\\n    function logBytes27(bytes27 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n    }\\n\\n    function logBytes28(bytes28 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n    }\\n\\n    function logBytes29(bytes29 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n    }\\n\\n    function logBytes30(bytes30 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n    }\\n\\n    function logBytes31(bytes31 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n    }\\n\\n    function logBytes32(bytes32 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n    }\\n\\n    function log(uint256 p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256)\\\", p0));\\n    }\\n\\n    function log(string memory p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n    }\\n\\n    function log(bool p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n    }\\n\\n    function log(address p0) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n    }\\n\\n    function log(uint256 p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n    }\\n\\n    function log(string memory p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n    }\\n\\n    function log(bool p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, uint256 p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, string memory p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, bool p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n    }\\n\\n    function log(address p0, address p1) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(string memory p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(bool p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, string memory p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, bool p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, string memory p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, bool p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n    }\\n\\n    function log(address p0, address p1, address p2) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(uint256,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(bool p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint256,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, bool p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint256,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, bool p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint256)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, bool p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n    }\\n\\n    function log(address p0, address p1, address p2, address p3) internal pure {\\n        _sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n    }\\n\\n}\\n\",\"keccak256\":\"0x7434453e6d3b7d0e5d0eb7846ffdbc27f0ccf3b163591263739b628074dc103a\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50612a76806100206000396000f3fe60806040526004361061008c5760003560e01c80630a3b8c7f1461009157806312c1f5e7146100b357806314ca3c7c146100d357806339d0486014610105578063529dca32146101255780637928483f14610138578063853c4abc14610158578063c0df6bbb14610178578063c715c47b14610198578063e39afb96146101bb578063e79a16f8146101db575b600080fd5b34801561009d57600080fd5b506100b16100ac366004611bc9565b6101fb565b005b3480156100bf57600080fd5b506100b16100ce366004611cbd565b610207565b3480156100df57600080fd5b506100e8610245565b6040516001600160a01b0390911681526020015b60405180910390f35b34801561011157600080fd5b506100b1610120366004611bc9565b610254565b6100b1610133366004611dea565b61025d565b34801561014457600080fd5b506100b1610153366004611bc9565b610271565b34801561016457600080fd5b506100b1610173366004611cbd565b61027a565b34801561018457600080fd5b506100b1610193366004611cbd565b6102b8565b3480156101a457600080fd5b506101ad6102f6565b6040519081526020016100fc565b3480156101c757600080fd5b506100b16101d6366004611cbd565b610300565b3480156101e757600080fd5b506100b16101f6366004611edf565b61033e565b6102048161034c565b50565b6102048160008151811061021d5761021d611f18565b60200260200101518260018151811061023857610238611f18565b602002602001015161037b565b600061024f610440565b905090565b6102048161045e565b61026a858585858561048a565b5050505050565b6102048161095a565b6102048160008151811061029057610290611f18565b6020026020010151826001815181106102ab576102ab611f18565b6020026020010151610989565b610204816000815181106102ce576102ce611f18565b6020026020010151826001815181106102e9576102e9611f18565b6020026020010151610995565b600061024f6109a1565b6102048160008151811061031657610316611f18565b60200260200101518260018151811061033157610331611f18565b60200260200101516109b6565b61034882826109c2565b5050565b6000610356610a05565b60010180546001600160a01b0319166001600160a01b03939093169290921790915550565b60176000610387610a05565b61ffff831660009081526005820160205260408120549192506001600160a01b03909116906103b4610a29565b604080516002808252606082018352929350889260009260208301908036833701905050905087816000815181106103ee576103ee611f18565b602002602001018181525050868160018151811061040e5761040e611f18565b60200260200101818152505060006104268285610aca565b905061043587868a8685610af6565b505050505050505050565b60008061044b610a05565b600401546001600160a01b031692915050565b6000610468610a05565b80546001600160a01b0319166001600160a01b03939093169290921790915550565b6000610494610a05565b9050600085516001600160401b038111156104b1576104b1611be6565b60405190808252806020026020018201604052801561050a57816020015b6040805160a0810182526000808252602080830182905292820181905260608201819052608082015282526000199092019101816104cf5790505b50905060005b865181101561094357600183015487516000916001600160a01b03169063a9e11893908a908590811061054557610545611f18565b60200260200101516040518263ffffffff1660e01b81526004016105699190611f7e565b600060405180830381865afa158015610586573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526105ae91908101906120d1565b8454606082015160405163ad66a5f160e01b815261ffff90911660048201529192506001600160a01b03169063ad66a5f190602401602060405180830381865afa158015610600573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062491906121f5565b8160800151146106745760405162461bcd60e51b81526020600482015260166024820152754e6f74206120546f6b656e204272696467652056414160501b60448201526064015b60405180910390fd5b835460e082015160405163ea63738d60e01b81526000926001600160a01b03169163ea63738d916106a89190600401611f7e565b600060405180830381865afa1580156106c5573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106ed919081019061220e565b90506106f830610b2f565b816080015114801561078d57508460010160009054906101000a90046001600160a01b03166001600160a01b0316639a8a05926040518163ffffffff1660e01b8152600401602060405180830381865afa15801561075a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061077e91906122d6565b61ffff168160a0015161ffff16145b6107e45760405162461bcd60e51b815260206004820152602260248201527f546f6b656e20776173206e6f742073656e7420746f2074686973206164647265604482015261737360f01b606482015260840161066b565b845489516001600160a01b039091169063c3f511c1908b908690811061080c5761080c611f18565b60200260200101516040518263ffffffff1660e01b81526004016108309190611f7e565b6000604051808303816000875af115801561084f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261087791908101906122f3565b50600061088c82606001518360400151610b3b565b9050600061089982610c5d565b6020840151909150600860ff831611156108d0576108b860088361233d565b6108c390600a61243a565b6108cd9082612449565b90505b6040518060a0016040528085604001518152602001856060015161ffff168152602001846001600160a01b03168152602001828152602001856020015181525087878151811061092257610922611f18565b602002602001018190525050505050508061093c90612460565b9050610510565b506109518782878787610cff565b50505050505050565b6000610964610a05565b60020180546001600160a01b0319166001600160a01b03939093169290921790915550565b601e6000610387610a05565b60056000610387610a05565b6000806109ac610a05565b6003015492915050565b60026000610387610a05565b60006109cc610a05565b61ffff939093166000908152600590930160205250604090912080546001600160a01b0319166001600160a01b03909216919091179055565b7fb331227f1bf35a6ac99b435b3538d39c2961a2e4b41a31d91747de11a066fa5690565b60606000610a35610d70565b9050806007018054610a4690612479565b80601f0160208091040260200160405190810160405280929190818152602001828054610a7290612479565b8015610abf5780601f10610a9457610100808354040283529160200191610abf565b820191906000526020600020905b815481529060010190602001808311610aa257829003601f168201915b505050505091505090565b6040518190610adf90849083906020016124ee565b604051602081830303815290604052905092915050565b60003382604051602001610b0b929190612513565b604051602081830303815290604052905061095186868360006203d090888a610d94565b6001600160a01b031690565b600080610b46610a05565b90508060010160009054906101000a90046001600160a01b03166001600160a01b0316639a8a05926040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bc191906122d6565b61ffff168461ffff1614610c4a578054604051630ff8f14360e11b815261ffff86166004820152602481018590526001600160a01b0390911690631ff1e28690604401602060405180830381865afa158015610c21573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c459190612537565b610c53565b610c5383610f13565b9150505b92915050565b60408051600481526024810182526020810180516001600160e01b031663313ce56760e01b179052905160009182916001600160a01b03851691610ca091612554565b600060405180830381855afa9150503d8060008114610cdb576040519150601f19603f3d011682016040523d82523d6000602084013e610ce0565b606091505b5091505080806020019051810190610cf89190612570565b9392505050565b6000610d09610a05565b6003810180549192506000610d1d83612460565b9190505550606086806020019051810190610d38919061258b565b6004840180546001600160a01b0319166001600160a01b0393909316929092179091559050610d6681610f3f565b5050505050505050565b7f4bc1672041418a922447d83c0efd37e6707ed20ab7e53ca3f20ce1d16cac307590565b600080610d9f610a05565b60408051600180825281830190925291925060009190816020015b610dc2611b3d565b815260200190600190039081610dba579050509050610de385858c8c610ffb565b81600081518110610df657610df6611f18565b6020908102919091010152600282015460405163c23ee3c360e01b815261ffff8c16600482015260248101899052604481018890526000916001600160a01b03169063c23ee3c3906064016040805180830381865afa158015610e5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8191906125db565b50600284015460405163329a2be760e01b81529192506001600160a01b03169063329a2be7908390610ec1908f908f908f908f908f908b906004016125ff565b60206040518083038185885af1158015610edf573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610f04919061269f565b9b9a5050505050505050505050565b600060a082901c15610f3b5760405163033b960d60e41b81526004810183905260240161066b565b5090565b60606000610f4b610d70565b60068101805461ffff19166101011790559050600080610f6a85611028565b915091506000610f7982611048565b9650905060078401610f8b8782612709565b50610f9683826110ce565b9450600386511080610fad5750600684015460ff16155b15610fdc578451610fc79060018601906020880190611b5d565b50505050600601805461ff0019169055919050565b610fe68587610aca565b9550610ff186610f3f565b5050505050919050565b611003611b3d565b61101f858585856040518060200160405280600081525061185e565b95945050505050565b6060808280602001905181019061103f91906127c8565b91509150915091565b602081015160608060005b600585516110619190612879565b8110156110c557818561107583600561288c565b8151811061108557611085611f18565b602001015160f81c60f81b6040516020016110a192919061289f565b604051602081830303815290604052915080806110bd90612460565b915050611053565b50919391925050565b606081600f600482811a9081901c8216911683600083810361116e5760408051600481526024810182526020810180516001600160e01b03166001600160e01b031989161790529051309161112291612554565b6000604051808303816000865af19150503d806000811461115f576040519150601f19603f3d011682016040523d82523d6000602084013e611164565b606091505b5092509050611210565b306001600160a01b0316858960405160240161118a91906128ce565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516111c89190612554565b6000604051808303816000865af19150503d8060008114611205576040519150601f19603f3d011682016040523d82523d6000602084013e61120a565b606091505b50925090505b8260ff1660000361126a576040805160018082528183019092526000916020808301908036833701905050905060008160008151811061125257611252611f18565b60209081029190910101529550610c57945050505050565b8260ff166001036113035760008280602001905181019061128b91906121f5565b905060008460ff166001600160401b038111156112aa576112aa611be6565b6040519080825280602002602001820160405280156112d3578160200160208202803683370190505b50905081816000815181106112ea576112ea611f18565b60209081029190910101529650610c5795505050505050565b8260ff166002036113f157611335604051806040016040528060068152602001654265666f726560d01b815250611a92565b6000808380602001905181019061134c91906125db565b9150915061135a8282611ad5565b60008560ff166001600160401b0381111561137757611377611be6565b6040519080825280602002602001820160405280156113a0578160200160208202803683370190505b50905082816000815181106113b7576113b7611f18565b60200260200101818152505081816001815181106113d7576113d7611f18565b60209081029190910101529750610c579650505050505050565b8260ff166003036114d35760008060008480602001905181019061141591906128e1565b92509250925060008660ff166001600160401b0381111561143857611438611be6565b604051908082528060200260200182016040528015611461578160200160208202803683370190505b509050838160008151811061147857611478611f18565b602002602001018181525050828160018151811061149857611498611f18565b60200260200101818152505081816002815181106114b8576114b8611f18565b60209081029190910101529850610c57975050505050505050565b8260ff166004036115d957600080600080858060200190518101906114f8919061290f565b935093509350935060008760ff166001600160401b0381111561151d5761151d611be6565b604051908082528060200260200182016040528015611546578160200160208202803683370190505b509050848160008151811061155d5761155d611f18565b602002602001018181525050838160018151811061157d5761157d611f18565b602002602001018181525050828160028151811061159d5761159d611f18565b60200260200101818152505081816003815181106115bd576115bd611f18565b60209081029190910101529950610c5798505050505050505050565b8260ff16600503611704576000806000806000868060200190518101906116009190612945565b9450945094509450945060008860ff166001600160401b0381111561162757611627611be6565b604051908082528060200260200182016040528015611650578160200160208202803683370190505b509050858160008151811061166757611667611f18565b602002602001018181525050848160018151811061168757611687611f18565b60200260200101818152505083816002815181106116a7576116a7611f18565b60200260200101818152505082816003815181106116c7576116c7611f18565b60200260200101818152505081816004815181106116e7576116e7611f18565b60209081029190910101529a50610c579950505050505050505050565b8260ff16600603611853576000806000806000808780602001905181019061172c9190612985565b95509550955095509550955060008960ff166001600160401b0381111561175557611755611be6565b60405190808252806020026020018201604052801561177e578160200160208202803683370190505b509050868160008151811061179557611795611f18565b60200260200101818152505085816001815181106117b5576117b5611f18565b60200260200101818152505084816002815181106117d5576117d5611f18565b60200260200101818152505083816003815181106117f5576117f5611f18565b602002602001018181525050828160048151811061181557611815611f18565b602002602001018181525050818160068151811061183557611835611f18565b60209081029190910101529b50610c579a5050505050505050505050565b505050505092915050565b611866611b3d565b6000611870610a05565b805460405163095ea7b360e01b81526001600160a01b0391821660048201526024810189905291925088169063095ea7b3906044016020604051808303816000875af11580156118c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118e891906129cf565b508054600182015460408051631a90a21960e01b815290516000936001600160a01b039081169363c5a5ebda93911691631a90a219916004808201926020929091908290030181865afa158015611943573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061196791906121f5565b8a8a8a6119738b610b2f565b60008b6040518863ffffffff1660e01b8152600401611997969594939291906129f1565b60206040518083038185885af11580156119b5573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906119da919061269f565b60408051606081018083526001860154634d4502c960e11b90915291519293509182916001600160a01b031690639a8a0592906064808501916020918187030181865afa158015611a2f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a5391906122d6565b61ffff1681528354602090910190611a73906001600160a01b0316610b2f565b8152602001826001600160401b03168152509250505095945050505050565b61020481604051602401611aa69190611f7e565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b179052611b18565b60405160248101839052604481018290526103489060640160408051601f198184030181529190526020810180516001600160e01b0316637b3338ad60e11b1790525b6102048160006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b604080516060810182526000808252602082018190529181019190915290565b828054828255906000526020600020908101928215611b98579160200282015b82811115611b98578251825591602001919060010190611b7d565b50610f3b9291505b80821115610f3b5760008155600101611ba0565b6001600160a01b038116811461020457600080fd5b600060208284031215611bdb57600080fd5b8135610cf881611bb4565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b0381118282101715611c1e57611c1e611be6565b60405290565b60405161016081016001600160401b0381118282101715611c1e57611c1e611be6565b60405161010081016001600160401b0381118282101715611c1e57611c1e611be6565b604051601f8201601f191681016001600160401b0381118282101715611c9257611c92611be6565b604052919050565b60006001600160401b03821115611cb357611cb3611be6565b5060051b60200190565b60006020808385031215611cd057600080fd5b82356001600160401b03811115611ce657600080fd5b8301601f81018513611cf757600080fd5b8035611d0a611d0582611c9a565b611c6a565b81815260059190911b82018301908381019087831115611d2957600080fd5b928401925b82841015611d4757833582529284019290840190611d2e565b979650505050505050565b60006001600160401b03821115611d6b57611d6b611be6565b50601f01601f191660200190565b600082601f830112611d8a57600080fd5b8135611d98611d0582611d52565b818152846020838601011115611dad57600080fd5b816020850160208301376000918101602001919091529392505050565b61ffff8116811461020457600080fd5b8035611de581611dca565b919050565b600080600080600060a08688031215611e0257600080fd5b85356001600160401b0380821115611e1957600080fd5b611e2589838a01611d79565b9650602091508188013581811115611e3c57600080fd5b8801601f81018a13611e4d57600080fd5b8035611e5b611d0582611c9a565b81815260059190911b8201840190848101908c831115611e7a57600080fd5b8584015b83811015611eb257803586811115611e965760008081fd5b611ea48f8983890101611d79565b845250918601918601611e7e565b50985050505060408801359450611ece91505060608701611dda565b949793965091946080013592915050565b60008060408385031215611ef257600080fd5b8235611efd81611dca565b91506020830135611f0d81611bb4565b809150509250929050565b634e487b7160e01b600052603260045260246000fd5b60005b83811015611f49578181015183820152602001611f31565b50506000910152565b60008151808452611f6a816020860160208601611f2e565b601f01601f19169290920160200192915050565b602081526000610cf86020830184611f52565b805160ff81168114611de557600080fd5b805163ffffffff81168114611de557600080fd5b8051611de581611dca565b80516001600160401b0381168114611de557600080fd5b600082601f830112611fe957600080fd5b8151611ff7611d0582611d52565b81815284602083860101111561200c57600080fd5b61201d826020830160208701611f2e565b949350505050565b600082601f83011261203657600080fd5b81516020612046611d0583611c9a565b82815260079290921b8401810191818101908684111561206557600080fd5b8286015b848110156120c657608081890312156120825760008081fd5b61208a611bfc565b81518152848201518582015260406120a3818401611f91565b9082015260606120b4838201611f91565b90820152835291830191608001612069565b509695505050505050565b6000602082840312156120e357600080fd5b81516001600160401b03808211156120fa57600080fd5b90830190610160828603121561210f57600080fd5b612117611c24565b61212083611f91565b815261212e60208401611fa2565b602082015261213f60408401611fa2565b604082015261215060608401611fb6565b60608201526080830151608082015261216b60a08401611fc1565b60a082015261217c60c08401611f91565b60c082015260e08301518281111561219357600080fd5b61219f87828601611fd8565b60e0830152506101006121b3818501611fa2565b9082015261012083810151838111156121cb57600080fd5b6121d788828701612025565b91830191909152506101409283015192810192909252509392505050565b60006020828403121561220757600080fd5b5051919050565b60006020828403121561222057600080fd5b81516001600160401b038082111561223757600080fd5b90830190610100828603121561224c57600080fd5b612254611c47565b61225d83611f91565b8152602083015160208201526040830151604082015261227f60608401611fb6565b60608201526080830151608082015261229a60a08401611fb6565b60a082015260c083015160c082015260e0830151828111156122bb57600080fd5b6122c787828601611fd8565b60e08301525095945050505050565b6000602082840312156122e857600080fd5b8151610cf881611dca565b60006020828403121561230557600080fd5b81516001600160401b0381111561231b57600080fd5b610c5384828501611fd8565b634e487b7160e01b600052601160045260246000fd5b60ff8281168282160390811115610c5757610c57612327565b600181815b8085111561239157816000190482111561237757612377612327565b8085161561238457918102915b93841c939080029061235b565b509250929050565b6000826123a857506001610c57565b816123b557506000610c57565b81600181146123cb57600281146123d5576123f1565b6001915050610c57565b60ff8411156123e6576123e6612327565b50506001821b610c57565b5060208310610133831016604e8410600b8410161715612414575081810a610c57565b61241e8383612356565b806000190482111561243257612432612327565b029392505050565b6000610cf860ff841683612399565b8082028115828204841417610c5757610c57612327565b60006001820161247257612472612327565b5060010190565b600181811c9082168061248d57607f821691505b6020821081036124ad57634e487b7160e01b600052602260045260246000fd5b50919050565b600081518084526020808501945080840160005b838110156124e3578151875295820195908201906001016124c7565b509495945050505050565b60408152600061250160408301856124b3565b828103602084015261101f8185611f52565b6001600160a01b038316815260406020820181905260009061201d90830184611f52565b60006020828403121561254957600080fd5b8151610cf881611bb4565b60008251612566818460208701611f2e565b9190910192915050565b60006020828403121561258257600080fd5b610cf882611f91565b6000806040838503121561259e57600080fd5b82516125a981611bb4565b60208401519092506001600160401b038111156125c557600080fd5b6125d185828601611fd8565b9150509250929050565b600080604083850312156125ee57600080fd5b505080516020909101519092909150565b600061ffff8089168352602060018060a01b03891681850152604060c08186015261262d60c086018a611f52565b60608681018a90526080870189905286820360a088015287518083528489019285019060005b8181101561268b57845180518916845287810151888501528601516001600160401b0316868401529386019391830191600101612653565b50909e9d5050505050505050505050505050565b6000602082840312156126b157600080fd5b610cf882611fc1565b601f82111561270457600081815260208120601f850160051c810160208610156126e15750805b601f850160051c820191505b81811015612700578281556001016126ed565b5050505b505050565b81516001600160401b0381111561272257612722611be6565b612736816127308454612479565b846126ba565b602080601f83116001811461276b57600084156127535750858301515b600019600386901b1c1916600185901b178555612700565b600085815260208120601f198616915b8281101561279a5788860151825594840194600190910190840161277b565b50858210156127b85787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b600080604083850312156127db57600080fd5b82516001600160401b03808211156127f257600080fd5b818501915085601f83011261280657600080fd5b81516020612816611d0583611c9a565b82815260059290921b8401810191818101908984111561283557600080fd5b948201945b838610156128535785518252948201949082019061283a565b9188015191965090935050508082111561286c57600080fd5b506125d185828601611fd8565b81810381811115610c5757610c57612327565b80820180821115610c5757610c57612327565b600083516128b1818460208801611f2e565b6001600160f81b0319939093169190920190815260010192915050565b602081526000610cf860208301846124b3565b6000806000606084860312156128f657600080fd5b8351925060208401519150604084015190509250925092565b6000806000806080858703121561292557600080fd5b505082516020840151604085015160609095015191969095509092509050565b600080600080600060a0868803121561295d57600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b60008060008060008060c0878903121561299e57600080fd5b865195506020870151945060408701519350606087015192506080870151915060a087015190509295509295509295565b6000602082840312156129e157600080fd5b81518015158114610cf857600080fd5b60018060a01b038716815285602082015261ffff8516604082015283606082015263ffffffff8316608082015260c060a08201526000612a3460c0830184611f52565b9897505050505050505056fea2646970667358221220e89468d4ca900c2dab88fe127baf4eda9662acbac33710270476498fb3780f4764736f6c63430008140033",
  "deployedBytecode": "0x60806040526004361061008c5760003560e01c80630a3b8c7f1461009157806312c1f5e7146100b357806314ca3c7c146100d357806339d0486014610105578063529dca32146101255780637928483f14610138578063853c4abc14610158578063c0df6bbb14610178578063c715c47b14610198578063e39afb96146101bb578063e79a16f8146101db575b600080fd5b34801561009d57600080fd5b506100b16100ac366004611bc9565b6101fb565b005b3480156100bf57600080fd5b506100b16100ce366004611cbd565b610207565b3480156100df57600080fd5b506100e8610245565b6040516001600160a01b0390911681526020015b60405180910390f35b34801561011157600080fd5b506100b1610120366004611bc9565b610254565b6100b1610133366004611dea565b61025d565b34801561014457600080fd5b506100b1610153366004611bc9565b610271565b34801561016457600080fd5b506100b1610173366004611cbd565b61027a565b34801561018457600080fd5b506100b1610193366004611cbd565b6102b8565b3480156101a457600080fd5b506101ad6102f6565b6040519081526020016100fc565b3480156101c757600080fd5b506100b16101d6366004611cbd565b610300565b3480156101e757600080fd5b506100b16101f6366004611edf565b61033e565b6102048161034c565b50565b6102048160008151811061021d5761021d611f18565b60200260200101518260018151811061023857610238611f18565b602002602001015161037b565b600061024f610440565b905090565b6102048161045e565b61026a858585858561048a565b5050505050565b6102048161095a565b6102048160008151811061029057610290611f18565b6020026020010151826001815181106102ab576102ab611f18565b6020026020010151610989565b610204816000815181106102ce576102ce611f18565b6020026020010151826001815181106102e9576102e9611f18565b6020026020010151610995565b600061024f6109a1565b6102048160008151811061031657610316611f18565b60200260200101518260018151811061033157610331611f18565b60200260200101516109b6565b61034882826109c2565b5050565b6000610356610a05565b60010180546001600160a01b0319166001600160a01b03939093169290921790915550565b60176000610387610a05565b61ffff831660009081526005820160205260408120549192506001600160a01b03909116906103b4610a29565b604080516002808252606082018352929350889260009260208301908036833701905050905087816000815181106103ee576103ee611f18565b602002602001018181525050868160018151811061040e5761040e611f18565b60200260200101818152505060006104268285610aca565b905061043587868a8685610af6565b505050505050505050565b60008061044b610a05565b600401546001600160a01b031692915050565b6000610468610a05565b80546001600160a01b0319166001600160a01b03939093169290921790915550565b6000610494610a05565b9050600085516001600160401b038111156104b1576104b1611be6565b60405190808252806020026020018201604052801561050a57816020015b6040805160a0810182526000808252602080830182905292820181905260608201819052608082015282526000199092019101816104cf5790505b50905060005b865181101561094357600183015487516000916001600160a01b03169063a9e11893908a908590811061054557610545611f18565b60200260200101516040518263ffffffff1660e01b81526004016105699190611f7e565b600060405180830381865afa158015610586573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526105ae91908101906120d1565b8454606082015160405163ad66a5f160e01b815261ffff90911660048201529192506001600160a01b03169063ad66a5f190602401602060405180830381865afa158015610600573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061062491906121f5565b8160800151146106745760405162461bcd60e51b81526020600482015260166024820152754e6f74206120546f6b656e204272696467652056414160501b60448201526064015b60405180910390fd5b835460e082015160405163ea63738d60e01b81526000926001600160a01b03169163ea63738d916106a89190600401611f7e565b600060405180830381865afa1580156106c5573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526106ed919081019061220e565b90506106f830610b2f565b816080015114801561078d57508460010160009054906101000a90046001600160a01b03166001600160a01b0316639a8a05926040518163ffffffff1660e01b8152600401602060405180830381865afa15801561075a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061077e91906122d6565b61ffff168160a0015161ffff16145b6107e45760405162461bcd60e51b815260206004820152602260248201527f546f6b656e20776173206e6f742073656e7420746f2074686973206164647265604482015261737360f01b606482015260840161066b565b845489516001600160a01b039091169063c3f511c1908b908690811061080c5761080c611f18565b60200260200101516040518263ffffffff1660e01b81526004016108309190611f7e565b6000604051808303816000875af115801561084f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261087791908101906122f3565b50600061088c82606001518360400151610b3b565b9050600061089982610c5d565b6020840151909150600860ff831611156108d0576108b860088361233d565b6108c390600a61243a565b6108cd9082612449565b90505b6040518060a0016040528085604001518152602001856060015161ffff168152602001846001600160a01b03168152602001828152602001856020015181525087878151811061092257610922611f18565b602002602001018190525050505050508061093c90612460565b9050610510565b506109518782878787610cff565b50505050505050565b6000610964610a05565b60020180546001600160a01b0319166001600160a01b03939093169290921790915550565b601e6000610387610a05565b60056000610387610a05565b6000806109ac610a05565b6003015492915050565b60026000610387610a05565b60006109cc610a05565b61ffff939093166000908152600590930160205250604090912080546001600160a01b0319166001600160a01b03909216919091179055565b7fb331227f1bf35a6ac99b435b3538d39c2961a2e4b41a31d91747de11a066fa5690565b60606000610a35610d70565b9050806007018054610a4690612479565b80601f0160208091040260200160405190810160405280929190818152602001828054610a7290612479565b8015610abf5780601f10610a9457610100808354040283529160200191610abf565b820191906000526020600020905b815481529060010190602001808311610aa257829003601f168201915b505050505091505090565b6040518190610adf90849083906020016124ee565b604051602081830303815290604052905092915050565b60003382604051602001610b0b929190612513565b604051602081830303815290604052905061095186868360006203d090888a610d94565b6001600160a01b031690565b600080610b46610a05565b90508060010160009054906101000a90046001600160a01b03166001600160a01b0316639a8a05926040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b9d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bc191906122d6565b61ffff168461ffff1614610c4a578054604051630ff8f14360e11b815261ffff86166004820152602481018590526001600160a01b0390911690631ff1e28690604401602060405180830381865afa158015610c21573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c459190612537565b610c53565b610c5383610f13565b9150505b92915050565b60408051600481526024810182526020810180516001600160e01b031663313ce56760e01b179052905160009182916001600160a01b03851691610ca091612554565b600060405180830381855afa9150503d8060008114610cdb576040519150601f19603f3d011682016040523d82523d6000602084013e610ce0565b606091505b5091505080806020019051810190610cf89190612570565b9392505050565b6000610d09610a05565b6003810180549192506000610d1d83612460565b9190505550606086806020019051810190610d38919061258b565b6004840180546001600160a01b0319166001600160a01b0393909316929092179091559050610d6681610f3f565b5050505050505050565b7f4bc1672041418a922447d83c0efd37e6707ed20ab7e53ca3f20ce1d16cac307590565b600080610d9f610a05565b60408051600180825281830190925291925060009190816020015b610dc2611b3d565b815260200190600190039081610dba579050509050610de385858c8c610ffb565b81600081518110610df657610df6611f18565b6020908102919091010152600282015460405163c23ee3c360e01b815261ffff8c16600482015260248101899052604481018890526000916001600160a01b03169063c23ee3c3906064016040805180830381865afa158015610e5d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e8191906125db565b50600284015460405163329a2be760e01b81529192506001600160a01b03169063329a2be7908390610ec1908f908f908f908f908f908b906004016125ff565b60206040518083038185885af1158015610edf573d6000803e3d6000fd5b50505050506040513d601f19601f82011682018060405250810190610f04919061269f565b9b9a5050505050505050505050565b600060a082901c15610f3b5760405163033b960d60e41b81526004810183905260240161066b565b5090565b60606000610f4b610d70565b60068101805461ffff19166101011790559050600080610f6a85611028565b915091506000610f7982611048565b9650905060078401610f8b8782612709565b50610f9683826110ce565b9450600386511080610fad5750600684015460ff16155b15610fdc578451610fc79060018601906020880190611b5d565b50505050600601805461ff0019169055919050565b610fe68587610aca565b9550610ff186610f3f565b5050505050919050565b611003611b3d565b61101f858585856040518060200160405280600081525061185e565b95945050505050565b6060808280602001905181019061103f91906127c8565b91509150915091565b602081015160608060005b600585516110619190612879565b8110156110c557818561107583600561288c565b8151811061108557611085611f18565b602001015160f81c60f81b6040516020016110a192919061289f565b604051602081830303815290604052915080806110bd90612460565b915050611053565b50919391925050565b606081600f600482811a9081901c8216911683600083810361116e5760408051600481526024810182526020810180516001600160e01b03166001600160e01b031989161790529051309161112291612554565b6000604051808303816000865af19150503d806000811461115f576040519150601f19603f3d011682016040523d82523d6000602084013e611164565b606091505b5092509050611210565b306001600160a01b0316858960405160240161118a91906128ce565b60408051601f198184030181529181526020820180516001600160e01b03166001600160e01b03199094169390931790925290516111c89190612554565b6000604051808303816000865af19150503d8060008114611205576040519150601f19603f3d011682016040523d82523d6000602084013e61120a565b606091505b50925090505b8260ff1660000361126a576040805160018082528183019092526000916020808301908036833701905050905060008160008151811061125257611252611f18565b60209081029190910101529550610c57945050505050565b8260ff166001036113035760008280602001905181019061128b91906121f5565b905060008460ff166001600160401b038111156112aa576112aa611be6565b6040519080825280602002602001820160405280156112d3578160200160208202803683370190505b50905081816000815181106112ea576112ea611f18565b60209081029190910101529650610c5795505050505050565b8260ff166002036113f157611335604051806040016040528060068152602001654265666f726560d01b815250611a92565b6000808380602001905181019061134c91906125db565b9150915061135a8282611ad5565b60008560ff166001600160401b0381111561137757611377611be6565b6040519080825280602002602001820160405280156113a0578160200160208202803683370190505b50905082816000815181106113b7576113b7611f18565b60200260200101818152505081816001815181106113d7576113d7611f18565b60209081029190910101529750610c579650505050505050565b8260ff166003036114d35760008060008480602001905181019061141591906128e1565b92509250925060008660ff166001600160401b0381111561143857611438611be6565b604051908082528060200260200182016040528015611461578160200160208202803683370190505b509050838160008151811061147857611478611f18565b602002602001018181525050828160018151811061149857611498611f18565b60200260200101818152505081816002815181106114b8576114b8611f18565b60209081029190910101529850610c57975050505050505050565b8260ff166004036115d957600080600080858060200190518101906114f8919061290f565b935093509350935060008760ff166001600160401b0381111561151d5761151d611be6565b604051908082528060200260200182016040528015611546578160200160208202803683370190505b509050848160008151811061155d5761155d611f18565b602002602001018181525050838160018151811061157d5761157d611f18565b602002602001018181525050828160028151811061159d5761159d611f18565b60200260200101818152505081816003815181106115bd576115bd611f18565b60209081029190910101529950610c5798505050505050505050565b8260ff16600503611704576000806000806000868060200190518101906116009190612945565b9450945094509450945060008860ff166001600160401b0381111561162757611627611be6565b604051908082528060200260200182016040528015611650578160200160208202803683370190505b509050858160008151811061166757611667611f18565b602002602001018181525050848160018151811061168757611687611f18565b60200260200101818152505083816002815181106116a7576116a7611f18565b60200260200101818152505082816003815181106116c7576116c7611f18565b60200260200101818152505081816004815181106116e7576116e7611f18565b60209081029190910101529a50610c579950505050505050505050565b8260ff16600603611853576000806000806000808780602001905181019061172c9190612985565b95509550955095509550955060008960ff166001600160401b0381111561175557611755611be6565b60405190808252806020026020018201604052801561177e578160200160208202803683370190505b509050868160008151811061179557611795611f18565b60200260200101818152505085816001815181106117b5576117b5611f18565b60200260200101818152505084816002815181106117d5576117d5611f18565b60200260200101818152505083816003815181106117f5576117f5611f18565b602002602001018181525050828160048151811061181557611815611f18565b602002602001018181525050818160068151811061183557611835611f18565b60209081029190910101529b50610c579a5050505050505050505050565b505050505092915050565b611866611b3d565b6000611870610a05565b805460405163095ea7b360e01b81526001600160a01b0391821660048201526024810189905291925088169063095ea7b3906044016020604051808303816000875af11580156118c4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118e891906129cf565b508054600182015460408051631a90a21960e01b815290516000936001600160a01b039081169363c5a5ebda93911691631a90a219916004808201926020929091908290030181865afa158015611943573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061196791906121f5565b8a8a8a6119738b610b2f565b60008b6040518863ffffffff1660e01b8152600401611997969594939291906129f1565b60206040518083038185885af11580156119b5573d6000803e3d6000fd5b50505050506040513d601f19601f820116820180604052508101906119da919061269f565b60408051606081018083526001860154634d4502c960e11b90915291519293509182916001600160a01b031690639a8a0592906064808501916020918187030181865afa158015611a2f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a5391906122d6565b61ffff1681528354602090910190611a73906001600160a01b0316610b2f565b8152602001826001600160401b03168152509250505095945050505050565b61020481604051602401611aa69190611f7e565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b179052611b18565b60405160248101839052604481018290526103489060640160408051601f198184030181529190526020810180516001600160e01b0316637b3338ad60e11b1790525b6102048160006a636f6e736f6c652e6c6f679050600080835160208501845afa505050565b604080516060810182526000808252602082018190529181019190915290565b828054828255906000526020600020908101928215611b98579160200282015b82811115611b98578251825591602001919060010190611b7d565b50610f3b9291505b80821115610f3b5760008155600101611ba0565b6001600160a01b038116811461020457600080fd5b600060208284031215611bdb57600080fd5b8135610cf881611bb4565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b0381118282101715611c1e57611c1e611be6565b60405290565b60405161016081016001600160401b0381118282101715611c1e57611c1e611be6565b60405161010081016001600160401b0381118282101715611c1e57611c1e611be6565b604051601f8201601f191681016001600160401b0381118282101715611c9257611c92611be6565b604052919050565b60006001600160401b03821115611cb357611cb3611be6565b5060051b60200190565b60006020808385031215611cd057600080fd5b82356001600160401b03811115611ce657600080fd5b8301601f81018513611cf757600080fd5b8035611d0a611d0582611c9a565b611c6a565b81815260059190911b82018301908381019087831115611d2957600080fd5b928401925b82841015611d4757833582529284019290840190611d2e565b979650505050505050565b60006001600160401b03821115611d6b57611d6b611be6565b50601f01601f191660200190565b600082601f830112611d8a57600080fd5b8135611d98611d0582611d52565b818152846020838601011115611dad57600080fd5b816020850160208301376000918101602001919091529392505050565b61ffff8116811461020457600080fd5b8035611de581611dca565b919050565b600080600080600060a08688031215611e0257600080fd5b85356001600160401b0380821115611e1957600080fd5b611e2589838a01611d79565b9650602091508188013581811115611e3c57600080fd5b8801601f81018a13611e4d57600080fd5b8035611e5b611d0582611c9a565b81815260059190911b8201840190848101908c831115611e7a57600080fd5b8584015b83811015611eb257803586811115611e965760008081fd5b611ea48f8983890101611d79565b845250918601918601611e7e565b50985050505060408801359450611ece91505060608701611dda565b949793965091946080013592915050565b60008060408385031215611ef257600080fd5b8235611efd81611dca565b91506020830135611f0d81611bb4565b809150509250929050565b634e487b7160e01b600052603260045260246000fd5b60005b83811015611f49578181015183820152602001611f31565b50506000910152565b60008151808452611f6a816020860160208601611f2e565b601f01601f19169290920160200192915050565b602081526000610cf86020830184611f52565b805160ff81168114611de557600080fd5b805163ffffffff81168114611de557600080fd5b8051611de581611dca565b80516001600160401b0381168114611de557600080fd5b600082601f830112611fe957600080fd5b8151611ff7611d0582611d52565b81815284602083860101111561200c57600080fd5b61201d826020830160208701611f2e565b949350505050565b600082601f83011261203657600080fd5b81516020612046611d0583611c9a565b82815260079290921b8401810191818101908684111561206557600080fd5b8286015b848110156120c657608081890312156120825760008081fd5b61208a611bfc565b81518152848201518582015260406120a3818401611f91565b9082015260606120b4838201611f91565b90820152835291830191608001612069565b509695505050505050565b6000602082840312156120e357600080fd5b81516001600160401b03808211156120fa57600080fd5b90830190610160828603121561210f57600080fd5b612117611c24565b61212083611f91565b815261212e60208401611fa2565b602082015261213f60408401611fa2565b604082015261215060608401611fb6565b60608201526080830151608082015261216b60a08401611fc1565b60a082015261217c60c08401611f91565b60c082015260e08301518281111561219357600080fd5b61219f87828601611fd8565b60e0830152506101006121b3818501611fa2565b9082015261012083810151838111156121cb57600080fd5b6121d788828701612025565b91830191909152506101409283015192810192909252509392505050565b60006020828403121561220757600080fd5b5051919050565b60006020828403121561222057600080fd5b81516001600160401b038082111561223757600080fd5b90830190610100828603121561224c57600080fd5b612254611c47565b61225d83611f91565b8152602083015160208201526040830151604082015261227f60608401611fb6565b60608201526080830151608082015261229a60a08401611fb6565b60a082015260c083015160c082015260e0830151828111156122bb57600080fd5b6122c787828601611fd8565b60e08301525095945050505050565b6000602082840312156122e857600080fd5b8151610cf881611dca565b60006020828403121561230557600080fd5b81516001600160401b0381111561231b57600080fd5b610c5384828501611fd8565b634e487b7160e01b600052601160045260246000fd5b60ff8281168282160390811115610c5757610c57612327565b600181815b8085111561239157816000190482111561237757612377612327565b8085161561238457918102915b93841c939080029061235b565b509250929050565b6000826123a857506001610c57565b816123b557506000610c57565b81600181146123cb57600281146123d5576123f1565b6001915050610c57565b60ff8411156123e6576123e6612327565b50506001821b610c57565b5060208310610133831016604e8410600b8410161715612414575081810a610c57565b61241e8383612356565b806000190482111561243257612432612327565b029392505050565b6000610cf860ff841683612399565b8082028115828204841417610c5757610c57612327565b60006001820161247257612472612327565b5060010190565b600181811c9082168061248d57607f821691505b6020821081036124ad57634e487b7160e01b600052602260045260246000fd5b50919050565b600081518084526020808501945080840160005b838110156124e3578151875295820195908201906001016124c7565b509495945050505050565b60408152600061250160408301856124b3565b828103602084015261101f8185611f52565b6001600160a01b038316815260406020820181905260009061201d90830184611f52565b60006020828403121561254957600080fd5b8151610cf881611bb4565b60008251612566818460208701611f2e565b9190910192915050565b60006020828403121561258257600080fd5b610cf882611f91565b6000806040838503121561259e57600080fd5b82516125a981611bb4565b60208401519092506001600160401b038111156125c557600080fd5b6125d185828601611fd8565b9150509250929050565b600080604083850312156125ee57600080fd5b505080516020909101519092909150565b600061ffff8089168352602060018060a01b03891681850152604060c08186015261262d60c086018a611f52565b60608681018a90526080870189905286820360a088015287518083528489019285019060005b8181101561268b57845180518916845287810151888501528601516001600160401b0316868401529386019391830191600101612653565b50909e9d5050505050505050505050505050565b6000602082840312156126b157600080fd5b610cf882611fc1565b601f82111561270457600081815260208120601f850160051c810160208610156126e15750805b601f850160051c820191505b81811015612700578281556001016126ed565b5050505b505050565b81516001600160401b0381111561272257612722611be6565b612736816127308454612479565b846126ba565b602080601f83116001811461276b57600084156127535750858301515b600019600386901b1c1916600185901b178555612700565b600085815260208120601f198616915b8281101561279a5788860151825594840194600190910190840161277b565b50858210156127b85787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b600080604083850312156127db57600080fd5b82516001600160401b03808211156127f257600080fd5b818501915085601f83011261280657600080fd5b81516020612816611d0583611c9a565b82815260059290921b8401810191818101908984111561283557600080fd5b948201945b838610156128535785518252948201949082019061283a565b9188015191965090935050508082111561286c57600080fd5b506125d185828601611fd8565b81810381811115610c5757610c57612327565b80820180821115610c5757610c57612327565b600083516128b1818460208801611f2e565b6001600160f81b0319939093169190920190815260010192915050565b602081526000610cf860208301846124b3565b6000806000606084860312156128f657600080fd5b8351925060208401519150604084015190509250925092565b6000806000806080858703121561292557600080fd5b505082516020840151604085015160609095015191969095509092509050565b600080600080600060a0868803121561295d57600080fd5b5050835160208501516040860151606087015160809097015192989197509594509092509050565b60008060008060008060c0878903121561299e57600080fd5b865195506020870151945060408701519350606087015192506080870151915060a087015190509295509295509295565b6000602082840312156129e157600080fd5b81518015158114610cf857600080fd5b60018060a01b038716815285602082015261ffff8516604082015283606082015263ffffffff8316608082015260c060a08201526000612a3460c0830184611f52565b9897505050505050505056fea2646970667358221220e89468d4ca900c2dab88fe127baf4eda9662acbac33710270476498fb3780f4764736f6c63430008140033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)": {
        "params": {
          "additionalVaas": "- Additional VAAs which were requested to be included in this delivery.   They are guaranteed to all be included and in the same order as was specified in the     delivery request.",
          "deliveryHash": "- the VAA hash of the deliveryVAA. NOTE: These signedVaas are NOT verified by the Wormhole core contract prior to being provided     to this call. Always make sure `parseAndVerify()` is called on the Wormhole core contract     before trusting the content of a raw VAA, otherwise the VAA may be invalid or malicious.",
          "payload": "- an arbitrary message which was included in the delivery by the     requester.",
          "sourceAddress": "- the (wormhole format) address on the sending chain which requested     this delivery.",
          "sourceChain": "- the wormhole chain ID where this delivery was requested."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "receiveWormholeMessages(bytes,bytes[],bytes32,uint16,bytes32)": {
        "notice": "When a `send` is performed with this contract as the target, this function will be     invoked by the WormholeRelayer contract NOTE: This function should be restricted such that only the Wormhole Relayer contract can call it. We also recommend that this function:   - Stores all received `deliveryHash`s in a mapping `(bytes32 => bool)`, and       on every call, checks that deliveryHash has not already been stored in the       map (This is to prevent other users maliciously trying to relay the same message)   - Checks that `sourceChain` and `sourceAddress` are indeed who       you expect to have requested the calling of `send` on the source chain The invocation of this function corresponding to the `send` request will have msg.value equal   to the receiverValue specified in the send request. If the invocation of this function reverts or exceeds the gas limit   specified by the send requester, this delivery will result in a `ReceiverFailure`."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}